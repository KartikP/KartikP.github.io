<!DOCTYPE html>
<html lang="en">

  <!-- Head -->
  <head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">    <!-- Metadata, OpenGraph and Schema.org -->
    
    <!-- Website verification -->
    <meta name="google-site-verification" content="">
<!-- Avoid warning on Google Chrome
        Error with Permissions-Policy header: Origin trial controlled feature not enabled: 'interest-cohort'.
        see https://stackoverflow.com/a/75119417
    -->
    <meta http-equiv="Permissions-Policy" content="interest-cohort=()">

    <!-- Standard metadata -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Tutorial - Non-Reverberating (i.e., Network Burst) Detection Workflow | Kartik  Pradeepan</title>
    <meta name="author" content="Kartik  Pradeepan">
    <meta name="description" content="A breakdown of how RSB detection code works on non-reverberating networks.">
    <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website">


    <!-- Bootstrap & MDB -->
    <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04">
    <!-- <link rel="stylesheet" href="/assets/css/mdb.min.css?62a43d1430ddb46fc4886f9d0e3b49b8"> -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous">

    <!-- Bootstrap Table -->
    <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.css">

    <!-- Fonts & Icons -->
    <link rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5">
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons">

    <!-- Code Syntax Highlighting -->
    <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?19f3075a2d19613090fe9e16b564e1fe" media="" id="highlight_theme_light">

    

    <!-- Styles -->
    
    <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;">
    
    <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e">
    <link rel="canonical" href="http://localhost:4000/projects/Non-Reverberating_Detection/">

    <!-- Dark Mode -->
    
    <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?e74e74bf055e5729d44a7d031a5ca6a5" media="none" id="highlight_theme_dark">
    <script src="/assets/js/theme.js?96d6b3e1c3604aca8b6134c7afdd5db6"></script>
    <script src="/assets/js/dark_mode.js?9b17307bb950ffa2e34be0227f53558f"></script>
    

  </head>

  <!-- Body -->
  <body class="fixed-top-nav ">

    <!-- Header -->
    <header>

      <!-- Nav Bar -->
      <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top">
        <div class="container">
          <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">Kartik </span>Pradeepan</a>
          <!-- Navbar Toggle -->
          <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar top-bar"></span>
            <span class="icon-bar middle-bar"></span>
            <span class="icon-bar bottom-bar"></span>
          </button>

          <div class="collapse navbar-collapse text-right" id="navbarNav">
            <ul class="navbar-nav ml-auto flex-nowrap">

              <!-- About -->
              <li class="nav-item ">
                <a class="nav-link" href="/">about</a>
              </li>
              
              <!-- Blog -->
              <li class="nav-item ">
                <a class="nav-link" href="/blog/">posts</a>
              </li>
              <!-- Notebook -->
              <li class="nav-item"><a class="nav-link" href="https://kartikp.github.io/Notebook" rel="external nofollow noopener" target="_blank">notebook</a></li> 
             <!-- Other pages -->
              <li class="nav-item ">
                <a class="nav-link" href="/publications/">publications</a>
              </li>
              <li class="nav-item ">
                <a class="nav-link" href="/projects/">projects</a>
              </li>
<!-- CV/Resume -->
               <li class="nav-item"><a class="nav-link" href="../assets/pdf/Kartik_Pradeepan_CV.pdf">cv</a></li>
               <li class="nav-item"><a class="nav-link" href="../assets/pdf/Kartik_Pradeepan_Resume.pdf">resume</a></li>

              <!-- Toogle theme mode -->
              <li class="toggle-container">
                <button id="light-toggle" title="Change theme">
                  <i class="fa-solid fa-moon"></i>
                  <i class="fa-solid fa-sun"></i>
                </button>
              </li>
            </ul>
          </div>
        </div>
      </nav>

      <!-- Scrolling Progress Bar -->
      <progress id="progress" value="0">
        <div class="progress-container">
          <span class="progress-bar"></span>
        </div>
      </progress>
    </header>


    <!-- Content -->
    <div class="container mt-5">
      
        <!-- page.html -->
<div class="post">

  <header class="post-header">
    <h1 class="post-title">Tutorial - Non-Reverberating (i.e., Network Burst) Detection Workflow</h1>
    <p class="post-description">A breakdown of how RSB detection code works on non-reverberating networks.</p>
  </header>

  <article>
    <p>This is a tutorial on how reverberating super bursts were detected in Pradeepan et al., 2023.</p>

<p><strong>This is a non-reverberating network example</strong></p>

<hr>

<p>DISCLAIMER: The approach used in the manuscript relies upon the generation of spike density functions - to convert a discrete, analog signal (i.e., 1s and 0s) into a continuous one (i.e., spike density function). By doing so, we are theoretically changing the signal into something it is not. However, through careful interrogation, we have assured the questions we asked are not biased by this step.</p>

<p>To navigate around this issue, I have also developed a different approach. This “secondary approach” avoids the convolution of a kernel and relies upon my implementation of the Max Interval Burst Detection algorithm combined with a histogram-based approach to detecting network events. By combining these two approaches, we’re able to cut the run time of the analysis by up to 95%, however the trade off is the accuracy of burst boundaries. Nonetheless, the results are still comparable. This secondary approach will be shared in this document as a hyperlink, including a separate tutorial at another time.</p>

<p><a href="/projects/Reverberating_Super_Burst_Detection/">Click here to see how the code performs on reverberating networks (i.e., reverberating-super bursts)</a></p>

<h2 id="install-necessary-packages">Install necessary packages</h2>

<p>Requirements: Pandas, Numpy, Matplotlib, Seaborn, Math, Scipy, Sci-kit learn</p>

<h2 id="import-libraries">Import libraries</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">pandas</span> <span class="k">as</span> <span class="n">pd</span>
<span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="n">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="kn">import</span> <span class="n">seaborn</span> <span class="k">as</span> <span class="n">sns</span>
<span class="kn">import</span> <span class="n">math</span>

<span class="kn">from</span> <span class="n">scipy.stats</span> <span class="kn">import</span> <span class="n">norm</span>
<span class="kn">from</span> <span class="n">scipy.signal</span> <span class="kn">import</span> <span class="n">convolve</span>
<span class="kn">from</span> <span class="n">scipy.signal</span> <span class="kn">import</span> <span class="n">find_peaks</span>
<span class="kn">from</span> <span class="n">scipy.signal</span> <span class="kn">import</span> <span class="n">resample</span>
<span class="kn">from</span> <span class="n">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">MinMaxScaler</span>

<span class="kn">from</span> <span class="n">sklearn.cluster</span> <span class="kn">import</span> <span class="n">KMeans</span>
<span class="kn">from</span> <span class="n">scipy.stats</span> <span class="kn">import</span> <span class="n">skew</span>
<span class="kn">from</span> <span class="n">scipy.stats</span> <span class="kn">import</span> <span class="n">mode</span>


</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">filename</span> <span class="o">=</span> <span class="sh">"</span><span class="s">/content/drive/MyDrive/Colab Notebooks/spike_data.csv</span><span class="sh">"</span>
<span class="n">fs</span> <span class="o">=</span> <span class="mi">12500</span>
</code></pre></div></div>

<h2 id="convert-axion-biosystems-spike_listcsv-file-into-a-dataframe">Convert Axion Biosystem’s spike_list.csv file into a dataframe</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">organize_spikelist</span><span class="p">(</span><span class="n">filepath</span><span class="p">):</span>
    <span class="c1"># Create neuralMetric dataframe
</span>    <span class="n">spikelist_file</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="nf">read_csv</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="sh">'</span><span class="se">\r\n</span><span class="sh">'</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
    <span class="n">spikelist_file</span> <span class="o">=</span> <span class="n">spikelist_file</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nb">str</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="sh">'</span><span class="s">,</span><span class="sh">'</span><span class="p">,</span> <span class="n">expand</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">spikelist_file</span><span class="p">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">spikelist_file</span><span class="p">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">spikelist_file</span> <span class="o">=</span> <span class="n">spikelist_file</span><span class="p">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

    <span class="n">spiketimes</span> <span class="o">=</span> <span class="n">spikelist_file</span><span class="p">[[</span><span class="sh">"</span><span class="s">Time (s)</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">Electrode</span><span class="sh">"</span><span class="p">]]</span>
    <span class="n">spiketimes</span> <span class="o">=</span> <span class="n">spiketimes</span><span class="p">.</span><span class="n">iloc</span><span class="p">[:</span><span class="o">-</span><span class="mi">8</span><span class="p">]</span>
    <span class="n">spiketimes</span> <span class="o">=</span> <span class="n">spiketimes</span><span class="p">.</span><span class="nf">dropna</span><span class="p">()</span>
    <span class="n">spiketimes</span> <span class="o">=</span> <span class="n">spiketimes</span><span class="p">[</span><span class="n">spiketimes</span><span class="p">[</span><span class="sh">"</span><span class="s">Electrode</span><span class="sh">"</span><span class="p">].</span><span class="nb">str</span><span class="p">.</span><span class="nf">contains</span><span class="p">(</span><span class="sh">"</span><span class="s">_</span><span class="sh">"</span><span class="p">)]</span>
    <span class="n">spiketimes</span> <span class="o">=</span> <span class="n">spiketimes</span><span class="p">.</span><span class="nf">astype</span><span class="p">({</span><span class="sh">"</span><span class="s">Time (s)</span><span class="sh">"</span><span class="p">:</span> <span class="nb">float</span><span class="p">})</span>
    <span class="n">spiketimes</span><span class="p">[</span><span class="sh">"</span><span class="s">Well</span><span class="sh">"</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">electrode</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="sh">"</span><span class="s">_</span><span class="sh">"</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">electrode</span> <span class="ow">in</span> <span class="nf">list</span><span class="p">(</span><span class="n">spiketimes</span><span class="p">[</span><span class="sh">"</span><span class="s">Electrode</span><span class="sh">"</span><span class="p">].</span><span class="n">values</span><span class="p">)]</span>
    <span class="n">spiketimes</span><span class="p">[</span><span class="sh">"</span><span class="s">Channel</span><span class="sh">"</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">electrode</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="sh">"</span><span class="s">_</span><span class="sh">"</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">electrode</span> <span class="ow">in</span> <span class="nf">list</span><span class="p">(</span><span class="n">spiketimes</span><span class="p">[</span><span class="sh">"</span><span class="s">Electrode</span><span class="sh">"</span><span class="p">].</span><span class="n">values</span><span class="p">)]</span>

    <span class="n">r</span><span class="p">,</span><span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="n">spikelist_file</span> <span class="o">==</span> <span class="sh">"</span><span class="s">Well Information</span><span class="sh">"</span><span class="p">)</span>
    <span class="n">metadata_slice</span> <span class="o">=</span> <span class="n">spikelist_file</span><span class="p">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]:].</span><span class="nf">transpose</span><span class="p">().</span><span class="nf">reset_index</span><span class="p">()</span>
    <span class="n">metadata_slice</span><span class="p">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">metadata_slice</span><span class="p">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">metadata_slice</span> <span class="o">=</span> <span class="n">metadata_slice</span><span class="p">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="n">metadata</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">label</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">well</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">metadata_slice</span><span class="p">[</span><span class="sh">"</span><span class="s">Well</span><span class="sh">"</span><span class="p">]):</span>
        <span class="k">if</span> <span class="n">well</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">metadata</span><span class="p">[</span><span class="n">well</span><span class="p">]</span> <span class="o">=</span> <span class="n">metadata_slice</span><span class="p">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="sh">"</span><span class="s">Treatment</span><span class="sh">"</span><span class="p">]</span>
            <span class="n">label</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="nf">str</span><span class="p">(</span><span class="n">well</span><span class="p">)</span><span class="o">+</span><span class="sh">"</span><span class="s">-</span><span class="sh">"</span><span class="o">+</span><span class="nf">str</span><span class="p">(</span><span class="n">metadata_slice</span><span class="p">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="sh">"</span><span class="s">Treatment</span><span class="sh">"</span><span class="p">]))</span>

    <span class="k">return</span> <span class="n">spiketimes</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span> <span class="n">label</span>

<span class="n">spiketimes</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="nf">organize_spikelist</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;ipython-input-6-2eeb288d4c56&gt;:3: ParserWarning: Falling back to the 'python' engine because the 'c' engine does not support regex separators (separators &gt; 1 char and different from '\s+' are interpreted as regex); you can avoid this warning by specifying engine='python'.
  spikelist_file = pd.read_csv(filepath, sep='\r\n', header=None)
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">spiketimes</span><span class="p">.</span><span class="nf">head</span><span class="p">()</span>
</code></pre></div></div>

<div id="df-774ba195-8454-4426-bd41-9a61dd31b1a4" class="colab-df-container">
    <div>
<style scoped="">
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Time (s)</th>
      <th>Electrode</th>
      <th>Well</th>
      <th>Channel</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <td>0.00184</td>
      <td>A1_76</td>
      <td>A1</td>
      <td>76</td>
    </tr>
    <tr>
      <th>2</th>
      <td>0.00824</td>
      <td>C1_51</td>
      <td>C1</td>
      <td>51</td>
    </tr>
    <tr>
      <th>3</th>
      <td>0.01160</td>
      <td>B1_47</td>
      <td>B1</td>
      <td>47</td>
    </tr>
    <tr>
      <th>4</th>
      <td>0.01984</td>
      <td>A1_42</td>
      <td>A1</td>
      <td>42</td>
    </tr>
    <tr>
      <th>5</th>
      <td>0.02224</td>
      <td>C1_41</td>
      <td>C1</td>
      <td>41</td>
    </tr>
  </tbody>
</table>
</div>
    <div class="colab-df-buttons">

  <div class="colab-df-container">
    <button class="colab-df-convert" onclick="convertToInteractive('df-774ba195-8454-4426-bd41-9a61dd31b1a4')" title="Convert this dataframe to an interactive table." style="display:none;">

  <svg xmlns="http://www.w3.org/2000/svg" height="24px" viewbox="0 -960 960 960">
    <path d="M120-120v-720h720v720H120Zm60-500h600v-160H180v160Zm220 220h160v-160H400v160Zm0 220h160v-160H400v160ZM180-400h160v-160H180v160Zm440 0h160v-160H620v160ZM180-180h160v-160H180v160Zm440 0h160v-160H620v160Z"></path>
  </svg>
    </button>

  <style>
    .colab-df-container {
      display:flex;
      gap: 12px;
    }

    .colab-df-convert {
      background-color: #E8F0FE;
      border: none;
      border-radius: 50%;
      cursor: pointer;
      display: none;
      fill: #1967D2;
      height: 32px;
      padding: 0 0 0 0;
      width: 32px;
    }

    .colab-df-convert:hover {
      background-color: #E2EBFA;
      box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15);
      fill: #174EA6;
    }

    .colab-df-buttons div {
      margin-bottom: 4px;
    }

    [theme=dark] .colab-df-convert {
      background-color: #3B4455;
      fill: #D2E3FC;
    }

    [theme=dark] .colab-df-convert:hover {
      background-color: #434B5C;
      box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15);
      filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3));
      fill: #FFFFFF;
    }
  </style>

    <script>
      const buttonEl =
        document.querySelector('#df-774ba195-8454-4426-bd41-9a61dd31b1a4 button.colab-df-convert');
      buttonEl.style.display =
        google.colab.kernel.accessAllowed ? 'block' : 'none';

      async function convertToInteractive(key) {
        const element = document.querySelector('#df-774ba195-8454-4426-bd41-9a61dd31b1a4');
        const dataTable =
          await google.colab.kernel.invokeFunction('convertToInteractive',
                                                    [key], {});
        if (!dataTable) return;

        const docLinkHtml = 'Like what you see? Visit the ' +
          '<a target="_blank" href=https://colab.research.google.com/notebooks/data_table.ipynb>data table notebook</a>'
          + ' to learn more about interactive tables.';
        element.innerHTML = '';
        dataTable['output_type'] = 'display_data';
        await google.colab.output.renderOutput(dataTable, element);
        const docLink = document.createElement('div');
        docLink.innerHTML = docLinkHtml;
        element.appendChild(docLink);
      }
    </script>
  </div>


<div id="df-f236a8fe-97bc-4023-9274-6bc2b02dd7b6">
  <button class="colab-df-quickchart" onclick="quickchart('df-f236a8fe-97bc-4023-9274-6bc2b02dd7b6')" title="Suggest charts." style="display:none;">

&lt;svg xmlns="http://www.w3.org/2000/svg" height="24px"viewBox="0 0 24 24"
     width="24px"&gt;
    <g>
        <path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zM9 17H7v-7h2v7zm4 0h-2V7h2v10zm4 0h-2v-4h2v4z"></path>
    </g>
&lt;/svg&gt;
  </button>

<style>
  .colab-df-quickchart {
      --bg-color: #E8F0FE;
      --fill-color: #1967D2;
      --hover-bg-color: #E2EBFA;
      --hover-fill-color: #174EA6;
      --disabled-fill-color: #AAA;
      --disabled-bg-color: #DDD;
  }

  [theme=dark] .colab-df-quickchart {
      --bg-color: #3B4455;
      --fill-color: #D2E3FC;
      --hover-bg-color: #434B5C;
      --hover-fill-color: #FFFFFF;
      --disabled-bg-color: #3B4455;
      --disabled-fill-color: #666;
  }

  .colab-df-quickchart {
    background-color: var(--bg-color);
    border: none;
    border-radius: 50%;
    cursor: pointer;
    display: none;
    fill: var(--fill-color);
    height: 32px;
    padding: 0;
    width: 32px;
  }

  .colab-df-quickchart:hover {
    background-color: var(--hover-bg-color);
    box-shadow: 0 1px 2px rgba(60, 64, 67, 0.3), 0 1px 3px 1px rgba(60, 64, 67, 0.15);
    fill: var(--button-hover-fill-color);
  }

  .colab-df-quickchart-complete:disabled,
  .colab-df-quickchart-complete:disabled:hover {
    background-color: var(--disabled-bg-color);
    fill: var(--disabled-fill-color);
    box-shadow: none;
  }

  .colab-df-spinner {
    border: 2px solid var(--fill-color);
    border-color: transparent;
    border-bottom-color: var(--fill-color);
    animation:
      spin 1s steps(1) infinite;
  }

  @keyframes spin {
    0% {
      border-color: transparent;
      border-bottom-color: var(--fill-color);
      border-left-color: var(--fill-color);
    }
    20% {
      border-color: transparent;
      border-left-color: var(--fill-color);
      border-top-color: var(--fill-color);
    }
    30% {
      border-color: transparent;
      border-left-color: var(--fill-color);
      border-top-color: var(--fill-color);
      border-right-color: var(--fill-color);
    }
    40% {
      border-color: transparent;
      border-right-color: var(--fill-color);
      border-top-color: var(--fill-color);
    }
    60% {
      border-color: transparent;
      border-right-color: var(--fill-color);
    }
    80% {
      border-color: transparent;
      border-right-color: var(--fill-color);
      border-bottom-color: var(--fill-color);
    }
    90% {
      border-color: transparent;
      border-bottom-color: var(--fill-color);
    }
  }
</style>

  <script>
    async function quickchart(key) {
      const quickchartButtonEl =
        document.querySelector('#' + key + ' button');
      quickchartButtonEl.disabled = true;  // To prevent multiple clicks.
      quickchartButtonEl.classList.add('colab-df-spinner');
      try {
        const charts = await google.colab.kernel.invokeFunction(
            'suggestCharts', [key], {});
      } catch (error) {
        console.error('Error during call to suggestCharts:', error);
      }
      quickchartButtonEl.classList.remove('colab-df-spinner');
      quickchartButtonEl.classList.add('colab-df-quickchart-complete');
    }
    (() => {
      let quickchartButtonEl =
        document.querySelector('#df-f236a8fe-97bc-4023-9274-6bc2b02dd7b6 button');
      quickchartButtonEl.style.display =
        google.colab.kernel.accessAllowed ? 'block' : 'none';
    })();
  </script>
</div>
    </div>
  </div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">spiketimes</span><span class="p">[</span><span class="sh">"</span><span class="s">Well</span><span class="sh">"</span><span class="p">].</span><span class="nf">unique</span><span class="p">()</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>array(['A1', 'C1', 'B1', 'A4', 'C2', 'B2', 'B4', 'A2', 'C3', 'C4', 'B3',
       'A3'], dtype=object)
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">spiketimes</span><span class="p">[</span><span class="sh">"</span><span class="s">Channel</span><span class="sh">"</span><span class="p">].</span><span class="nf">unique</span><span class="p">()</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>array(['76', '51', '47', '42', '41', '16', '26', '13', '18', '31', '84',
       '44', '82', '38', '85', '32', '88', '78', '11', '72', '87', '75',
       '48', '62', '24', '65', '63', '25', '15', '43', '81', '61', '46',
       '58', '83', '55', '57', '52', '12', '73', '22', '56', '67', '77',
       '66', '53', '36', '74', '86', '45', '23', '33', '21', '14', '71',
       '17', '37', '35', '28', '54', '27', '34', '68', '64'], dtype=object)
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">duration</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="n">math</span><span class="p">.</span><span class="nf">ceil</span><span class="p">(</span><span class="nf">max</span><span class="p">(</span><span class="n">spiketimes</span><span class="p">[</span><span class="sh">"</span><span class="s">Time (s)</span><span class="sh">"</span><span class="p">])</span><span class="o">/</span><span class="mf">100.0</span><span class="p">))</span><span class="o">*</span><span class="mi">100</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">It appears the duration of these recordings was </span><span class="si">{</span><span class="n">duration</span><span class="si">}</span><span class="s"> seconds.</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>It appears the duration of these recordings was 300 seconds.
</code></pre></div></div>

<p>The data that we’ll be dealing with are spike times from a 12-well multielectrode array system. Each well contains 64 channels (arranged in an 8x8 grid). Channels are labeled according to a cartesian coordinate system where the first digit represents x (or the row) and the second digit represents y (or the column).</p>

<h2 id="select-a-well-to-analyze">Select a well to analyze</h2>
<p>This is where you would start wrapping the below code into a loop that iterates through each well, each plate/recording.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">well_id</span> <span class="o">=</span> <span class="sh">"</span><span class="s">B1</span><span class="sh">"</span>
</code></pre></div></div>

<h2 id="quick-look-at-the-network-activity">Quick look at the network activity</h2>
<p>Here we are plotting a histogram of spike times from the well we selected, using a bin size of 0.1 seconds (300 second duration/3000 bins).</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plt</span><span class="p">.</span><span class="nf">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">hist</span><span class="p">(</span><span class="n">spiketimes</span><span class="p">[</span><span class="n">spiketimes</span><span class="p">[</span><span class="sh">"</span><span class="s">Well</span><span class="sh">"</span><span class="p">]</span><span class="o">==</span><span class="n">well_id</span><span class="p">][</span><span class="sh">"</span><span class="s">Time (s)</span><span class="sh">"</span><span class="p">],</span> <span class="n">bins</span><span class="o">=</span><span class="mi">3000</span><span class="p">);</span>
<span class="n">sns</span><span class="p">.</span><span class="nf">despine</span><span class="p">()</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">xlabel</span><span class="p">(</span><span class="sh">"</span><span class="s">Time (s)</span><span class="sh">"</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">ylabel</span><span class="p">(</span><span class="sh">"</span><span class="s">Total number of spikes in network (Bin size:1s)</span><span class="sh">"</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">title</span><span class="p">(</span><span class="sh">"</span><span class="s">Sort of like a PSTH - representing network activity</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Text(0.5, 1.0, 'Sort of like a PSTH - representing network activity')
</code></pre></div></div>

<p><img width="100%" alt="image" src="../Non-Reverberating_Detection_files/Non-Reverberating_Detection_16_1.png"></p>

<p>It looks like this network is a non-reverberating network. Each large amplitude firing rate event does not appear to have a tail.</p>

<p>We’ll plot a close up of a smaller window.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Definitely do not keep plotting histograms with large bin sizes if you want your code to run fast
</span><span class="n">plt</span><span class="p">.</span><span class="nf">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">hist</span><span class="p">(</span><span class="n">spiketimes</span><span class="p">[</span><span class="n">spiketimes</span><span class="p">[</span><span class="sh">"</span><span class="s">Well</span><span class="sh">"</span><span class="p">]</span><span class="o">==</span><span class="n">well_id</span><span class="p">][</span><span class="sh">"</span><span class="s">Time (s)</span><span class="sh">"</span><span class="p">],</span> <span class="n">bins</span><span class="o">=</span><span class="mi">3000</span><span class="p">);</span>
<span class="n">sns</span><span class="p">.</span><span class="nf">despine</span><span class="p">()</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">xlim</span><span class="p">(</span><span class="mi">146</span><span class="p">,</span> <span class="mi">157</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">xlabel</span><span class="p">(</span><span class="sh">"</span><span class="s">Time (s)</span><span class="sh">"</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">ylabel</span><span class="p">(</span><span class="sh">"</span><span class="s">Total number of spikes in network (Bin size:1s)</span><span class="sh">"</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">title</span><span class="p">(</span><span class="sh">"</span><span class="s">Single peak within a network event</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Text(0.5, 1.0, 'Multiple peaks within a network event')
</code></pre></div></div>

<p><img width="75%" alt="image" src="../Non-Reverberating_Detection_files/Non-Reverberating_Detection_18_1.png"></p>

<h2 id="sort-data-frame-containing-mixed-bag-of-electrode-and-spike-times-based-on-channel-name">Sort data frame containing mixed-bag of electrode and spike times based on channel name</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">channel_ids</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">j</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">+</span> <span class="mi">9</span><span class="p">)]</span>
<span class="sh">'''</span><span class="s">
The above produces the following:
  [11, 12, 13, 14, 15, 16, 17, 18,
  21, 22, 23, 24, 25, 26, 27, 28,
  31, 32, 33, 34, 35, 36, 37, 38,
  41, 42, 43, 44, 45, 46, 47, 48,
  51, 52, 53, 54, 55, 56, 57, 58,
  61, 62, 63, 64, 65, 66, 67, 68,
  71, 72, 73, 74, 75, 76, 77, 78,
  81, 82, 83, 84, 85, 86, 87, 88]
</span><span class="sh">'''</span>

<span class="k">def</span> <span class="nf">generate_raster</span><span class="p">(</span><span class="n">spiketimes</span><span class="p">,</span> <span class="n">well_id</span><span class="p">,</span> <span class="n">duration</span><span class="p">,</span> <span class="n">channel_ids</span><span class="p">):</span>
  <span class="sh">'''</span><span class="s">
  well_data: Data frame in the format seen above
  duration: Length of recording in seconds (in this case 300 seconds)
  channel_ids: Name of all channels in the format seen in the data frame </span><span class="sh">"</span><span class="s">channel</span><span class="sh">"</span><span class="s"> column
  </span><span class="sh">'''</span>
  <span class="n">raster</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="c1"># Loop through each channel regardless of activity
</span>  <span class="n">well_spiketimes</span> <span class="o">=</span> <span class="n">spiketimes</span><span class="p">[</span><span class="n">spiketimes</span><span class="p">[</span><span class="sh">"</span><span class="s">Well</span><span class="sh">"</span><span class="p">]</span> <span class="o">==</span> <span class="n">well_id</span><span class="p">].</span><span class="nf">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="n">channel_ids</span><span class="p">:</span>
    <span class="c1"># If the channel is found in my data (i.e., it had at least 1 spike)
</span>    <span class="k">if</span> <span class="nf">str</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span> <span class="ow">in</span> <span class="n">well_spiketimes</span><span class="p">[</span><span class="sh">"</span><span class="s">Channel</span><span class="sh">"</span><span class="p">].</span><span class="nf">to_list</span><span class="p">():</span>
      <span class="c1"># Find spike times associated with that channel
</span>      <span class="n">spiketrain</span> <span class="o">=</span> <span class="n">well_spiketimes</span><span class="p">.</span><span class="n">loc</span><span class="p">[</span><span class="n">well_spiketimes</span><span class="p">[</span><span class="sh">"</span><span class="s">Channel</span><span class="sh">"</span><span class="p">]</span><span class="o">==</span><span class="nf">str</span><span class="p">(</span><span class="n">channel</span><span class="p">),</span> <span class="n">well_spiketimes</span><span class="p">.</span><span class="n">columns</span><span class="p">.</span><span class="nb">str</span><span class="p">.</span><span class="nf">contains</span><span class="p">(</span><span class="sh">"</span><span class="s">Time</span><span class="sh">"</span><span class="p">)].</span><span class="nf">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
      <span class="c1"># Convert spike times that occur before the end of the recording (i.e., duration) to an array
</span>      <span class="n">spiketrain</span> <span class="o">=</span> <span class="n">spiketrain</span><span class="p">.</span><span class="nf">to_numpy</span><span class="p">().</span><span class="nf">flatten</span><span class="p">()[</span><span class="n">spiketrain</span><span class="p">.</span><span class="nf">to_numpy</span><span class="p">().</span><span class="nf">flatten</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">duration</span><span class="p">]</span>
      <span class="c1"># Store array
</span>      <span class="n">raster</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">spiketrain</span><span class="p">)</span>
    <span class="c1"># If the channel is not found in my data, I still want to store that it was empty
</span>    <span class="k">else</span><span class="p">:</span>
      <span class="n">raster</span><span class="p">.</span><span class="nf">append</span><span class="p">([])</span>
  <span class="k">return</span> <span class="n">raster</span>

<span class="n">raster</span> <span class="o">=</span> <span class="nf">generate_raster</span><span class="p">(</span><span class="n">spiketimes</span><span class="p">,</span> <span class="n">well_id</span><span class="p">,</span> <span class="n">duration</span><span class="p">,</span> <span class="n">channel_ids</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="visualize-network-activity-as-a-raster-plot">Visualize network activity (as a raster plot)</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plt</span><span class="p">.</span><span class="nf">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="n">plt</span><span class="p">.</span><span class="n">rcParams</span><span class="p">.</span><span class="nf">update</span><span class="p">({</span><span class="sh">'</span><span class="s">font.size</span><span class="sh">'</span><span class="p">:</span> <span class="mi">12</span><span class="p">})</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">rc</span><span class="p">(</span><span class="sh">'</span><span class="s">axes</span><span class="sh">'</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">eventplot</span><span class="p">(</span><span class="n">raster</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="sh">'</span><span class="s">black</span><span class="sh">'</span><span class="p">,</span> <span class="n">linelengths</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">linewidths</span><span class="o">=</span><span class="mf">0.75</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.35</span><span class="p">);</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">ylabel</span><span class="p">(</span><span class="sh">"</span><span class="s">Channels</span><span class="sh">"</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">xlabel</span><span class="p">(</span><span class="sh">"</span><span class="s">Time (s)</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Text(0.5, 0, 'Time (s)')
</code></pre></div></div>

<p><img width="100%" alt="image" src="../Non-Reverberating_Detection_files/Non-Reverberating_Detection_22_1.png"></p>

<p>We did it with the histogram, might as well do it with the raster. 🤷</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plt</span><span class="p">.</span><span class="nf">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="n">plt</span><span class="p">.</span><span class="n">rcParams</span><span class="p">.</span><span class="nf">update</span><span class="p">({</span><span class="sh">'</span><span class="s">font.size</span><span class="sh">'</span><span class="p">:</span> <span class="mi">12</span><span class="p">})</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">rc</span><span class="p">(</span><span class="sh">'</span><span class="s">axes</span><span class="sh">'</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">eventplot</span><span class="p">(</span><span class="n">raster</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="sh">'</span><span class="s">black</span><span class="sh">'</span><span class="p">,</span> <span class="n">linelengths</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">linewidths</span><span class="o">=</span><span class="mf">0.75</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.35</span><span class="p">);</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">xlim</span><span class="p">(</span><span class="mi">146</span><span class="p">,</span> <span class="mi">157</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">ylabel</span><span class="p">(</span><span class="sh">"</span><span class="s">Channels</span><span class="sh">"</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">xlabel</span><span class="p">(</span><span class="sh">"</span><span class="s">Time (s)</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Text(0.5, 0, 'Time (s)')
</code></pre></div></div>

<p><img width="100%" alt="image" src="../Non-Reverberating_Detection_files/Non-Reverberating_Detection_24_1.png"></p>

<h1 id="signal-conditioning">Signal Conditioning</h1>

<h2 id="approach-1-generate-spike-density-function">Approach 1: Generate spike density function</h2>

<h3 id="gaussian-kernel">Gaussian Kernel</h3>
<p>Note: You should be using a bandwidth optimized kernel. Refer to Shimazaki &amp; Shinomoto, 2010</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">generate_gaussian_kernel</span><span class="p">(</span><span class="n">sigma</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="mi">12500</span><span class="p">):</span>
    <span class="sh">'''</span><span class="s">
    :param sigma: Width of kernel
    :param fs: Sampling frequency in Hz
    :return: Gaussian kernel
    </span><span class="sh">'''</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">arange</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span> <span class="o">*</span> <span class="n">sigma</span><span class="p">,</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">sigma</span><span class="p">,</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">fs</span><span class="p">)</span>
    <span class="n">kernel</span> <span class="o">=</span> <span class="n">norm</span><span class="p">.</span><span class="nf">pdf</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span>
    <span class="n">kernel</span> <span class="o">=</span> <span class="n">kernel</span> <span class="o">/</span> <span class="nf">max</span><span class="p">(</span><span class="n">kernel</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">kernel</span>
</code></pre></div></div>

<h3 id="binary-spike-matrix">Binary spike matrix</h3>
<p>Create a matrix of nChannels x Y time points, where Y is the duration * sampling frequency.
Each cell will contain either a 0 or 1 depending on whether a spike was found i.e., 1 or not i.e., 0.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">generate_spikematrix</span><span class="p">(</span><span class="n">spiketrain</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="mi">12500</span><span class="p">,</span> <span class="n">duration</span><span class="o">=</span><span class="mi">300</span><span class="p">):</span>
    <span class="sh">'''</span><span class="s">
    :param spiketrain: Takes spikes times from a single channel
    :param fs: Sampling frequency in Hz
    :param duration: Duration of recording in seconds
    :return: spikematrix: Binary matrix containing spikes
    </span><span class="sh">'''</span>
    <span class="n">spiketimes</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">(</span><span class="n">spiketrain</span><span class="p">)</span>
    <span class="n">spiketimes</span> <span class="o">=</span> <span class="n">spiketimes</span><span class="p">[</span><span class="n">spiketimes</span> <span class="o">&lt;=</span> <span class="n">duration</span><span class="p">]</span>  <span class="c1"># Ensure recording is desired length
</span>    <span class="n">spikematrix</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">duration</span> <span class="o">*</span> <span class="n">fs</span><span class="p">)</span>  <span class="c1"># Generate empty spike matrix with appropriate number of bins
</span>    <span class="k">for</span> <span class="n">spike</span> <span class="ow">in</span> <span class="n">spiketimes</span><span class="p">:</span>
        <span class="n">spikematrix</span><span class="p">[</span><span class="nf">int</span><span class="p">(</span><span class="n">spike</span> <span class="o">*</span> <span class="n">fs</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">spikematrix</span>
</code></pre></div></div>

<h3 id="convolve-gaussian-kernel-and-spike-matrix">Convolve gaussian kernel and spike matrix</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">generate_sdf</span><span class="p">(</span><span class="n">spikematrix</span><span class="p">,</span> <span class="n">gaussian_kernel</span><span class="p">):</span>
    <span class="sh">'''</span><span class="s">
    :param spikematrix: Binary matrix containing spikes
    :param gaussian_kernel: Gaussian kernel to be convolved with spikematrix
    :return: sdf: Continuous timeseries representing probability distribution of activity
    </span><span class="sh">'''</span>
    <span class="n">sdf_tmp</span> <span class="o">=</span> <span class="nf">convolve</span><span class="p">(</span><span class="n">spikematrix</span><span class="p">,</span> <span class="n">gaussian_kernel</span><span class="p">)</span>
    <span class="n">sdf</span> <span class="o">=</span> <span class="n">sdf_tmp</span><span class="p">[</span><span class="nf">int</span><span class="p">((</span><span class="nf">len</span><span class="p">(</span><span class="n">sdf_tmp</span><span class="p">)</span><span class="o">-</span><span class="nf">len</span><span class="p">(</span><span class="n">spikematrix</span><span class="p">))</span><span class="o">/</span><span class="mi">2</span><span class="p">):</span><span class="nf">int</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">sdf_tmp</span><span class="p">)</span><span class="o">-</span><span class="p">((</span><span class="nf">len</span><span class="p">(</span><span class="n">sdf_tmp</span><span class="p">)</span><span class="o">-</span><span class="nf">len</span><span class="p">(</span><span class="n">spikematrix</span><span class="p">))</span><span class="o">/</span><span class="mi">2</span><span class="p">))]</span>
    <span class="n">sdf</span> <span class="o">=</span> <span class="n">sdf</span><span class="o">/</span><span class="nf">max</span><span class="p">(</span><span class="n">gaussian_kernel</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">sdf</span>
</code></pre></div></div>

<h3 id="iterate-through-each-channel-and-generate-the-channels-sdf">Iterate through each channel, and generate the channel’s SDF</h3>
<p>Convolution takes some time because the spike matrix is quite large. There is a way to avoid spike density function generation by relying solely on histograms (like you saw above) but the timing of network event boundaries will be less precise.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">kernel</span> <span class="o">=</span> <span class="nf">generate_gaussian_kernel</span><span class="p">(</span><span class="n">sigma</span><span class="o">=</span><span class="mf">0.075</span><span class="p">)</span>

<span class="n">maxFR</span><span class="p">,</span> <span class="n">channel_sdf</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">channel</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">channel_ids</span><span class="p">):</span>
  <span class="n">spiketrain</span> <span class="o">=</span> <span class="n">raster</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
  <span class="n">channel_spikematrix</span> <span class="o">=</span> <span class="nf">generate_spikematrix</span><span class="p">(</span><span class="n">spiketrain</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="n">fs</span><span class="p">,</span> <span class="n">duration</span><span class="o">=</span><span class="n">duration</span><span class="p">)</span>
  <span class="n">sdf_tmp</span> <span class="o">=</span> <span class="nf">generate_sdf</span><span class="p">(</span><span class="n">channel_spikematrix</span><span class="p">,</span> <span class="n">kernel</span><span class="p">)</span>
  <span class="n">channel_sdf</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">sdf_tmp</span><span class="p">)</span>
  <span class="n">maxFR</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="nf">max</span><span class="p">(</span><span class="n">sdf_tmp</span><span class="p">))</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">network_sdf</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">mean</span><span class="p">(</span><span class="n">channel_sdf</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">weighted_network_sdf</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">average</span><span class="p">(</span><span class="n">channel_sdf</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">maxFR</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plt</span><span class="p">.</span><span class="nf">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">duration</span><span class="p">,</span><span class="mi">1</span><span class="o">/</span><span class="mi">12500</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">network_sdf</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">weighted_network_sdf</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">xlim</span><span class="p">(</span><span class="mi">146</span><span class="p">,</span> <span class="mi">157</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">ylabel</span><span class="p">(</span><span class="sh">"</span><span class="s">Channels/Firing Rate (Hz)</span><span class="sh">"</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">xlabel</span><span class="p">(</span><span class="sh">"</span><span class="s">Time (s)</span><span class="sh">"</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">legend</span><span class="p">([</span><span class="sh">"</span><span class="s">Network SDF</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">Weighted Network SDF</span><span class="sh">"</span><span class="p">])</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;matplotlib.legend.Legend at 0x7b94503f2560&gt;
</code></pre></div></div>

<p><img width="100%" alt="image" src="../Non-Reverberating_Detection_files/Non-Reverberating_Detection_37_1.png"></p>

<p>As you can see, the general shape of the spike density function (which is an estimate of the network’s instantaneous firing rate) is the same between the non-maxFR-weighted SDF and the maxFR-weighted SDF. You can use whichever one, but I prefer to use the maxFR-weighted SDF because it helps improve signal:noise for subsequent analysis.</p>

<h2 id="visualize-raster-plot-and-spike-density-function">Visualize raster plot and spike density function</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plt</span><span class="p">.</span><span class="nf">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="n">plt</span><span class="p">.</span><span class="n">rcParams</span><span class="p">.</span><span class="nf">update</span><span class="p">({</span><span class="sh">'</span><span class="s">font.size</span><span class="sh">'</span><span class="p">:</span> <span class="mi">12</span><span class="p">})</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">rc</span><span class="p">(</span><span class="sh">'</span><span class="s">axes</span><span class="sh">'</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">eventplot</span><span class="p">(</span><span class="n">raster</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="sh">'</span><span class="s">black</span><span class="sh">'</span><span class="p">,</span> <span class="n">linelengths</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">linewidths</span><span class="o">=</span><span class="mf">0.75</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.35</span><span class="p">);</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">duration</span><span class="p">,</span><span class="mi">1</span><span class="o">/</span><span class="n">fs</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">weighted_network_sdf</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="sh">'</span><span class="s">black</span><span class="sh">'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">xlim</span><span class="p">(</span><span class="mi">146</span><span class="p">,</span> <span class="mi">157</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">ylabel</span><span class="p">(</span><span class="sh">"</span><span class="s">Channels/Firing Rate (Hz)</span><span class="sh">"</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">xlabel</span><span class="p">(</span><span class="sh">"</span><span class="s">Time (s)</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Text(0.5, 0, 'Time (s)')
</code></pre></div></div>

<p><img width="100%" alt="image" src="../Non-Reverberating_Detection_files/Non-Reverberating_Detection_40_1.png"></p>

<p>As you can see, generally the spike density function does a really good job of representing the average activity across the network. You may notice that the “ramp-up” prior to each network burst starts before activity has truly started. This is largely an artifact of the gaussian kernel. To avoid this, you can use an alpha function or any function that you feel represents the probability of an action potential the best. For this example, and generally most purposes, a gaussian kernel will suffice.</p>

<h1 id="reverberating-network-detection">Reverberating Network Detection</h1>

<h2 id="did-this-network-have-a-sufficiently-high-firing-rate-to-warrant-further-analysis">Did this network have a sufficiently high firing rate to warrant further analysis?</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">isBursting</span> <span class="o">=</span> <span class="bp">False</span>
<span class="n">BURST_THRESHOLD</span> <span class="o">=</span> <span class="mi">5</span>
<span class="k">if</span> <span class="nf">max</span><span class="p">(</span><span class="n">weighted_network_sdf</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">BURST_THRESHOLD</span><span class="p">:</span>
  <span class="n">isBursting</span> <span class="o">=</span> <span class="bp">True</span>

<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Is Network Bursting? </span><span class="si">{</span><span class="n">isBursting</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Is Network Bursting? True
</code></pre></div></div>

<h2 id="peak-detection">Peak detection</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">detect_burst_peaks</span><span class="p">(</span><span class="n">sdf</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="mi">12500</span><span class="p">):</span>
    <span class="sh">'''</span><span class="s">
    :param sdf: Spike density function
    :param fr: Minimum average firing rate (amplitude in SDF) required to be considered a burst
    :return: Burst peak times
    </span><span class="sh">'''</span>
    <span class="n">burst_peaks</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="nf">find_peaks</span><span class="p">(</span><span class="n">sdf</span><span class="p">,</span> <span class="n">prominence</span><span class="o">=</span><span class="n">delta</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">burst_peaks</span><span class="o">/</span><span class="n">fs</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">burst_peak_times</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">prime_burst_peak_times</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">if</span> <span class="n">isBursting</span><span class="p">:</span>
  <span class="n">burst_peak_times</span> <span class="o">=</span> <span class="nf">detect_burst_peaks</span><span class="p">(</span><span class="n">weighted_network_sdf</span><span class="p">)</span>
  <span class="n">prime_burst_peak_times</span> <span class="o">=</span> <span class="nf">detect_burst_peaks</span><span class="p">(</span><span class="n">weighted_network_sdf</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="nf">max</span><span class="p">(</span><span class="n">weighted_network_sdf</span><span class="p">)</span><span class="o">*</span><span class="mf">0.5</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Detected </span><span class="si">{</span><span class="nf">len</span><span class="p">(</span><span class="n">burst_peak_times</span><span class="p">)</span><span class="si">}</span><span class="s"> potential network bursts and </span><span class="si">{</span><span class="nf">len</span><span class="p">(</span><span class="n">prime_burst_peak_times</span><span class="p">)</span><span class="si">}</span><span class="s"> likely initiation bursts.</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Detected 104 potential network bursts and 97 likely initiation bursts.
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plt</span><span class="p">.</span><span class="nf">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="n">plt</span><span class="p">.</span><span class="n">rcParams</span><span class="p">.</span><span class="nf">update</span><span class="p">({</span><span class="sh">'</span><span class="s">font.size</span><span class="sh">'</span><span class="p">:</span> <span class="mi">12</span><span class="p">})</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">rc</span><span class="p">(</span><span class="sh">'</span><span class="s">axes</span><span class="sh">'</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">eventplot</span><span class="p">(</span><span class="n">raster</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="sh">'</span><span class="s">black</span><span class="sh">'</span><span class="p">,</span> <span class="n">linelengths</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">linewidths</span><span class="o">=</span><span class="mf">0.75</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.35</span><span class="p">);</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">duration</span><span class="p">,</span><span class="mi">1</span><span class="o">/</span><span class="n">fs</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">weighted_network_sdf</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="sh">'</span><span class="s">black</span><span class="sh">'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">xlim</span><span class="p">(</span><span class="mi">135</span><span class="p">,</span><span class="mi">165</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">ylabel</span><span class="p">(</span><span class="sh">"</span><span class="s">Channels/Firing Rate (Hz)</span><span class="sh">"</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">xlabel</span><span class="p">(</span><span class="sh">"</span><span class="s">Time (s)</span><span class="sh">"</span><span class="p">)</span>
<span class="n">sns</span><span class="p">.</span><span class="nf">despine</span><span class="p">()</span>

<span class="n">plt</span><span class="p">.</span><span class="nf">plot</span><span class="p">(</span><span class="n">burst_peak_times</span><span class="p">,</span> <span class="n">weighted_network_sdf</span><span class="p">[(</span><span class="n">burst_peak_times</span><span class="o">*</span><span class="n">fs</span><span class="p">).</span><span class="nf">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)],</span> <span class="sh">'</span><span class="s">v</span><span class="sh">'</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[&lt;matplotlib.lines.Line2D at 0x7b9455b5d6f0&gt;]
</code></pre></div></div>

<p><img width="100%" alt="image" src="../Non-Reverberating_Detection_files/Non-Reverberating_Detection_48_1.png"></p>

<p>As you can see, our really basic peak detection was able to identify the location of all the network bursts in this recording. Depending on how noisy your activity is, you may need a more complicated approach.</p>

<h2 id="cluster-burst-peaks-along-inter-burst-peak-interval-and-firing-rate-dimensions">Cluster burst peaks along inter-burst-peak-interval and firing rate dimensions</h2>

<h3 id="visualize-data">Visualize data</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ibpi</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">diff</span><span class="p">(</span><span class="n">burst_peak_times</span><span class="p">)</span>
<span class="n">fr</span> <span class="o">=</span> <span class="n">weighted_network_sdf</span><span class="p">[(</span><span class="n">burst_peak_times</span><span class="o">*</span><span class="n">fs</span><span class="p">).</span><span class="nf">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)]</span>
<span class="n">sns</span><span class="p">.</span><span class="nf">scatterplot</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">ibpi</span><span class="p">,</span><span class="n">y</span><span class="o">=</span><span class="n">fr</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
<span class="n">sns</span><span class="p">.</span><span class="nf">despine</span><span class="p">()</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">xlabel</span><span class="p">(</span><span class="sh">"</span><span class="s">Inter-burst-peak-interval (s)</span><span class="sh">"</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">ylabel</span><span class="p">(</span><span class="sh">"</span><span class="s">Firing rate (Hz)</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Text(0, 0.5, 'Firing rate (Hz)')
</code></pre></div></div>

<p><img width="75%" alt="image" src="../Non-Reverberating_Detection_files/Non-Reverberating_Detection_52_1.png"></p>

<p>This approach ignores the first burst. We can deal with that later.</p>

<p>Importantly, this network detected small amplitude bursts that have a similar rate as mini-bursts. The important distinction is a strong overlap in the IBPI dimension. We will quantify that in the next step.</p>

<h3 id="k-means-clustering">K-means clustering</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">k_means</span><span class="p">(</span><span class="n">ibpi</span><span class="p">,</span> <span class="n">fr</span><span class="p">):</span>
  <span class="n">features</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">transpose</span><span class="p">([</span><span class="n">ibpi</span><span class="p">,</span> <span class="n">fr</span><span class="p">[</span><span class="mi">1</span><span class="p">:]])</span>
  <span class="c1">#scaler = StandardScaler()
</span>  <span class="c1">#scaled_features = scaler.fit_transform(features)
</span>
  <span class="n">kmeans_kwargs</span> <span class="o">=</span> <span class="p">{</span>
      <span class="sh">"</span><span class="s">init</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">random</span><span class="sh">"</span><span class="p">,</span>
      <span class="sh">"</span><span class="s">n_init</span><span class="sh">"</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
      <span class="sh">"</span><span class="s">max_iter</span><span class="sh">"</span><span class="p">:</span> <span class="mi">250</span><span class="p">,</span>
      <span class="sh">"</span><span class="s">random_state</span><span class="sh">"</span><span class="p">:</span> <span class="mi">0</span>
  <span class="p">}</span>
  <span class="n">kmeans</span> <span class="o">=</span> <span class="nc">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="o">**</span><span class="n">kmeans_kwargs</span><span class="p">)</span>
  <span class="n">kmeans</span><span class="p">.</span><span class="nf">fit</span><span class="p">(</span><span class="n">features</span><span class="p">)</span>

  <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">transpose</span><span class="p">(</span><span class="n">features</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
  <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">transpose</span><span class="p">(</span><span class="n">features</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>

  <span class="c1"># Assign the mini-burst cluster as label 1
</span>  <span class="k">if</span> <span class="n">np</span><span class="p">.</span><span class="nf">nanmean</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">kmeans</span><span class="p">.</span><span class="n">labels_</span><span class="o">==</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">np</span><span class="p">.</span><span class="nf">nanmean</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">kmeans</span><span class="p">.</span><span class="n">labels_</span><span class="o">==</span><span class="mi">1</span><span class="p">]):</span>
    <span class="n">cluster_x_1</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">kmeans</span><span class="p">.</span><span class="n">labels_</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">cluster_x_2</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">kmeans</span><span class="p">.</span><span class="n">labels_</span><span class="o">==</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">cluster_y_1</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">kmeans</span><span class="p">.</span><span class="n">labels_</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">cluster_y_2</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">kmeans</span><span class="p">.</span><span class="n">labels_</span><span class="o">==</span><span class="mi">1</span><span class="p">]</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">cluster_x_1</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">kmeans</span><span class="p">.</span><span class="n">labels_</span><span class="o">==</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">cluster_x_2</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">kmeans</span><span class="p">.</span><span class="n">labels_</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">cluster_y_1</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">kmeans</span><span class="p">.</span><span class="n">labels_</span><span class="o">==</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">cluster_y_2</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">kmeans</span><span class="p">.</span><span class="n">labels_</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span>
  <span class="c1">#sns.scatterplot(x=cluster_x_1, y=cluster_y_1, color='green')
</span>  <span class="c1">#sns.scatterplot(x=cluster_x_2, y=cluster_y_2, color='red')
</span>
  <span class="c1"># Check what the percent of overlap is
</span>  <span class="n">num_of_bins</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">fr</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
  <span class="c1"># Overlapping x
</span>  <span class="n">rng_x</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="n">cluster_x_1</span><span class="p">.</span><span class="nf">min</span><span class="p">(),</span> <span class="n">cluster_x_2</span><span class="p">.</span><span class="nf">min</span><span class="p">()),</span> <span class="nf">max</span><span class="p">(</span><span class="n">cluster_x_1</span><span class="p">.</span><span class="nf">max</span><span class="p">(),</span> <span class="n">cluster_x_2</span><span class="p">.</span><span class="nf">max</span><span class="p">())</span>
  <span class="n">n1_x</span><span class="p">,</span> <span class="n">bins1_x</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">histogram</span><span class="p">(</span><span class="n">cluster_x_1</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">num_of_bins</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="n">rng_x</span><span class="p">)</span>
  <span class="n">n2_x</span><span class="p">,</span> <span class="n">bins2_x</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">histogram</span><span class="p">(</span><span class="n">cluster_x_2</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">num_of_bins</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="n">rng_x</span><span class="p">)</span>
  <span class="n">intersection_x</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">minimum</span><span class="p">(</span><span class="n">n1_x</span><span class="p">,</span><span class="n">n2_x</span><span class="p">)</span>

  <span class="n">overlapping_bins_x</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">nonzero</span><span class="p">(</span><span class="n">intersection_x</span><span class="p">)</span>
  <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">overlapping_bins_x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
      <span class="n">overlapping_bursts_x</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="n">n1_x</span><span class="p">[</span><span class="n">overlapping_bins_x</span><span class="p">]</span> <span class="o">+</span> <span class="n">n2_x</span><span class="p">[</span><span class="n">overlapping_bins_x</span><span class="p">])</span>
      <span class="n">percent_overlapping_x</span> <span class="o">=</span> <span class="n">overlapping_bursts_x</span><span class="o">/</span><span class="nf">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
      <span class="n">percent_overlapping_x</span> <span class="o">=</span> <span class="mi">0</span>

  <span class="nf">if </span><span class="p">(</span><span class="n">percent_overlapping_x</span> <span class="o">&gt;</span> <span class="mf">0.2</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="nf">sum</span><span class="p">(</span><span class="n">kmeans</span><span class="p">.</span><span class="n">labels_</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span><span class="o">&lt;</span><span class="nf">sum</span><span class="p">(</span><span class="n">kmeans</span><span class="p">.</span><span class="n">labels_</span><span class="o">==</span><span class="mi">0</span><span class="p">)):</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">The well is probably not reverberating strongly if at all</span><span class="sh">"</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">False</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">kmeans</span><span class="p">.</span><span class="n">labels_</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">The well is probably reverberating</span><span class="sh">"</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">True</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">kmeans</span><span class="p">.</span><span class="n">labels_</span>


<span class="n">isReverb</span><span class="p">,</span> <span class="n">cluster_x</span><span class="p">,</span> <span class="n">cluster_y</span><span class="p">,</span> <span class="n">labels</span> <span class="o">=</span> <span class="nf">k_means</span><span class="p">(</span><span class="n">ibpi</span><span class="p">,</span> <span class="n">fr</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>The well is probably not reverberating strongly if at all
</code></pre></div></div>

<p>K-means used percent overlap along the IBPI dimension as well as the total number of labeled “mini-bursts” to initiation burst. Generally, there should be as much or more mini-bursts to initiation bursts.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sns</span><span class="p">.</span><span class="nf">scatterplot</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">cluster_x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">cluster_y</span><span class="p">,</span> <span class="n">hue</span><span class="o">=</span><span class="n">labels</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">xlabel</span><span class="p">(</span><span class="sh">"</span><span class="s">Inter-burst-peak-interval (s)</span><span class="sh">"</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">ylabel</span><span class="p">(</span><span class="sh">"</span><span class="s">Firing rate (Hz)</span><span class="sh">"</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">title</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Reverberation status: </span><span class="si">{</span><span class="n">isReverb</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
<span class="n">sns</span><span class="p">.</span><span class="nf">despine</span><span class="p">()</span>
</code></pre></div></div>

<p><img width="75%" alt="image" src="../Non-Reverberating_Detection_files/Non-Reverberating_Detection_57_0.png"></p>

<h3 id="inter-burst-peak-interval-skewness">Inter-burst-peak-interval skewness</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">burst_skewness</span><span class="p">(</span><span class="n">ibpi</span><span class="p">):</span>
  <span class="k">if</span> <span class="nf">skew</span><span class="p">(</span><span class="n">ibpi</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">return</span> <span class="bp">True</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="bp">False</span>

<span class="n">ibpi_skewness</span> <span class="o">=</span> <span class="nf">burst_skewness</span><span class="p">(</span><span class="n">burst_peak_times</span><span class="p">)</span>

<span class="n">sns</span><span class="p">.</span><span class="nf">histplot</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">ibpi</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">xlabel</span><span class="p">(</span><span class="sh">"</span><span class="s">Inter-burst-peak-interval (s)</span><span class="sh">"</span><span class="p">)</span>
<span class="n">sns</span><span class="p">.</span><span class="nf">despine</span><span class="p">()</span>
</code></pre></div></div>

<p><img width="75%" alt="image" src="../Non-Reverberating_Detection_files/Non-Reverberating_Detection_59_0.png"></p>

<h2 id="rmax-calculation-crawling-the-histogram">Rmax calculation (Crawling the histogram)</h2>

<p><strong>NOTE: For a non-reverberating network, we can skip this step entirely.</strong></p>

<p>There are a number of different approaches to find the local minimum between a distribution. I initially attempted using Hartigan’s Dip Test (via Unidip package) but found that depending on the frequency of network events, it would struggle to detect the local minimum. The approach that I found first that worked best was trying to replicate how my visual detection worked. In essence, I would plot histograms with varying bin sizes/ number of bins and see if there was a point where there was a 0 count bin between the two clear peaks. That approach worked most of the time. The issue with it is that it goes with the first bin that has a 0 count, which may result in certain RSBs being missed. This did a good enough job to be the main approach for Pradeepan et al., 2023.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">hist_find_rmax</span><span class="p">(</span><span class="n">ibpi</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">steps</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
  <span class="n">initiation_burst</span> <span class="o">=</span> <span class="n">ibpi</span><span class="p">[</span><span class="n">labels</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span>
  <span class="n">max_num_bins</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">ibpi</span><span class="o">/</span><span class="mf">1.5</span><span class="p">))</span>
  <span class="n">rmax</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="n">r_tmp</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="n">s_tmp</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="nf">if </span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">median</span><span class="p">(</span><span class="n">ibpi</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">np</span><span class="p">.</span><span class="nf">median</span><span class="p">(</span><span class="n">initiation_burst</span><span class="p">)):</span>
    <span class="k">for</span> <span class="n">size</span> <span class="ow">in</span> <span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">arange</span><span class="p">(</span><span class="n">max_num_bins</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="n">steps</span><span class="p">)):</span>
      <span class="n">counts</span><span class="p">,</span> <span class="n">binEdges</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">histogram</span><span class="p">(</span><span class="n">ibpi</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">size</span><span class="p">)</span>
      <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="n">counts</span><span class="o">==</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">first_min</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="n">counts</span><span class="o">==</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">rmax_tmp</span> <span class="o">=</span> <span class="n">binEdges</span><span class="p">[</span><span class="n">first_min</span><span class="p">]</span>
        <span class="n">r_tmp</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">rmax_tmp</span><span class="p">)</span>
        <span class="n">s_tmp</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
        <span class="nf">if </span><span class="p">(</span><span class="n">rmax_tmp</span> <span class="o">&gt;</span> <span class="n">rmax</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">rmax_tmp</span> <span class="o">&lt;</span> <span class="p">(</span><span class="nf">mode</span><span class="p">(</span><span class="nf">list</span><span class="p">(</span><span class="nf">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">initiation_burst</span><span class="p">)))[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mf">0.9</span><span class="p">)):</span>
          <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">New Rmax found of </span><span class="si">{</span><span class="n">rmax_tmp</span><span class="si">}</span><span class="s"> using </span><span class="si">{</span><span class="n">size</span><span class="si">}</span><span class="s"> bin histogram</span><span class="sh">"</span><span class="p">)</span>
          <span class="n">rmax</span> <span class="o">=</span> <span class="n">rmax_tmp</span>
  <span class="k">return</span> <span class="n">rmax</span>

<span class="n">hist_rmax</span> <span class="o">=</span> <span class="nf">hist_find_rmax</span><span class="p">(</span><span class="n">ibpi</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">steps</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">The calculated Rmax using histogram crawling was </span><span class="si">{</span><span class="n">hist_rmax</span><span class="si">}</span><span class="s"> seconds.</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>New Rmax found of 1.299259029126173 using 103 bin histogram
New Rmax found of 1.302605940594019 using 101 bin histogram
New Rmax found of 1.3060880808080402 using 99 bin histogram
New Rmax found of 1.3097138144329492 using 97 bin histogram
New Rmax found of 1.3134922105262754 using 95 bin histogram
New Rmax found of 1.3141374647886919 using 71 bin histogram
New Rmax found of 1.3194678260869162 using 69 bin histogram
New Rmax found of 1.3251164179104074 using 67 bin histogram
New Rmax found of 1.3311126153845751 using 65 bin histogram
New Rmax found of 1.3374895238094835 using 63 bin histogram
New Rmax found of 1.3425443902438623 using 41 bin histogram
New Rmax found of 1.3534317948717547 using 39 bin histogram
New Rmax found of 1.3654962162161761 using 37 bin histogram
New Rmax found of 1.3789394285713887 using 35 bin histogram
New Rmax found of 1.3940121212120813 using 33 bin histogram
New Rmax found of 1.4203893333332938 using 15 bin histogram
New Rmax found of 1.465027692307653 using 13 bin histogram
New Rmax found of 1.5258981818181432 using 11 bin histogram
The calculated Rmax using histogram crawling was 1.5258981818181432 seconds.
</code></pre></div></div>

<p>Because there are two clusters, Rmax calculation attempted to find a minimum. This would give us false boundaries. That is why in the burst reconstruction loop, “isReverb” needs to be true to use Rmax.</p>

<h2 id="rmax-calculation-simple-overlap">Rmax calculation (Simple overlap)</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">overlap_find_rmax</span><span class="p">(</span><span class="n">ibpi</span><span class="p">,</span> <span class="n">labels</span><span class="p">):</span>
  <span class="n">initiation_bursts</span> <span class="o">=</span> <span class="n">ibpi</span><span class="p">[</span><span class="n">labels</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span>
  <span class="n">mini_bursts</span> <span class="o">=</span> <span class="n">ibpi</span><span class="p">[</span><span class="n">labels</span><span class="o">==</span><span class="mi">1</span><span class="p">]</span>

  <span class="n">overlap_start</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="nf">min</span><span class="p">(</span><span class="n">initiation_bursts</span><span class="p">),</span> <span class="nf">min</span><span class="p">(</span><span class="n">mini_bursts</span><span class="p">))</span>
  <span class="n">overlap_end</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="nf">max</span><span class="p">(</span><span class="n">initiation_bursts</span><span class="p">),</span> <span class="nf">max</span><span class="p">(</span><span class="n">mini_bursts</span><span class="p">))</span>

  <span class="k">return</span> <span class="n">overlap_start</span>

<span class="n">overlap_rmax</span> <span class="o">=</span> <span class="nf">overlap_find_rmax</span><span class="p">(</span><span class="n">ibpi</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">The calculated Rmax using min overlap was </span><span class="si">{</span><span class="n">overlap_rmax</span><span class="si">}</span><span class="s"> seconds.</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>The calculated Rmax using min overlap was 1.9411200000000122 seconds.
</code></pre></div></div>

<p>This is an alternative approach that is computationally cheaper and works as well.</p>

<p>You can use these functions to also calculate Amax, or the maximum amplitude to be considered a mini-bursts.</p>

<h1 id="burst-detection-loop">Burst Detection Loop</h1>
<p>This part of the algorithm calculates the ordinary burst boundaries (regardless of RSB status). These burst boundaries will be merged in the next step.</p>

<p>Recall, this is our spike density function. We are going to detect where the bursts start and end. Generally these line up when the first derivative peaks (i.e., begins to decline).</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plt</span><span class="p">.</span><span class="nf">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="n">plt</span><span class="p">.</span><span class="n">rcParams</span><span class="p">.</span><span class="nf">update</span><span class="p">({</span><span class="sh">'</span><span class="s">font.size</span><span class="sh">'</span><span class="p">:</span> <span class="mi">12</span><span class="p">})</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">rc</span><span class="p">(</span><span class="sh">'</span><span class="s">axes</span><span class="sh">'</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">duration</span><span class="p">,</span><span class="mi">1</span><span class="o">/</span><span class="n">fs</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">eventplot</span><span class="p">(</span><span class="n">raster</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="sh">'</span><span class="s">black</span><span class="sh">'</span><span class="p">,</span> <span class="n">linelengths</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">linewidths</span><span class="o">=</span><span class="mf">0.75</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.35</span><span class="p">);</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">weighted_network_sdf</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="sh">'</span><span class="s">black</span><span class="sh">'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">xlim</span><span class="p">(</span><span class="mi">146</span><span class="p">,</span> <span class="mi">157</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">ylabel</span><span class="p">(</span><span class="sh">"</span><span class="s">Firing Rate (Hz)</span><span class="sh">"</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">xlabel</span><span class="p">(</span><span class="sh">"</span><span class="s">Time (s)</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Text(0.5, 0, 'Time (s)')
</code></pre></div></div>

<p><img width="100%" alt="image" src="../Non-Reverberating_Detection_files/Non-Reverberating_Detection_69_1.png"></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plt</span><span class="p">.</span><span class="nf">plot</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">np</span><span class="p">.</span><span class="nf">diff</span><span class="p">(</span><span class="n">weighted_network_sdf</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="sh">'</span><span class="s">red</span><span class="sh">'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">xlim</span><span class="p">(</span><span class="mi">146</span><span class="p">,</span> <span class="mi">149</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(146.0, 149.0)
</code></pre></div></div>

<p><img width="100%" alt="image" src="../Non-Reverberating_Detection_files/Non-Reverberating_Detection_70_1.png"></p>

<h2 id="resample-the-signal">Resample the signal</h2>

<p>However, as you can tell, because of the sampling frequency of the original signal (12.5kHz), the signal is too noisy. This will make detecting any local maxima or minima difficult.</p>

<p>To address, we are going to downsample the original SDF. In hindsight, you could do this much earlier one when first generating your spike density function. It should be more appropriately placed in the “Signal Conditioning” section.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">RESAMPLE_FACTOR</span> <span class="o">=</span> <span class="mi">150</span>
<span class="n">ds_weighted_network_sdf</span> <span class="o">=</span> <span class="nf">resample</span><span class="p">(</span><span class="n">weighted_network_sdf</span><span class="p">,</span> <span class="nf">int</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">weighted_network_sdf</span><span class="p">)</span><span class="o">/</span><span class="n">RESAMPLE_FACTOR</span><span class="p">))</span>
</code></pre></div></div>

<p>Sanity check, but a resample factor of 150 seems to be good for us. Preserves enough.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Scale the arrays between 0 and 1 so that we can plot the SDF and the first
# derivative together and see them both
</span><span class="n">min_max_scaler</span> <span class="o">=</span> <span class="nc">MinMaxScaler</span><span class="p">()</span>
<span class="n">scaled_ds_sdf</span> <span class="o">=</span> <span class="n">min_max_scaler</span><span class="p">.</span><span class="nf">fit_transform</span><span class="p">(</span><span class="n">ds_weighted_network_sdf</span><span class="p">.</span><span class="nf">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">duration</span><span class="p">,</span><span class="n">RESAMPLE_FACTOR</span><span class="o">/</span><span class="n">fs</span><span class="p">)</span>
<span class="n">first_deriv</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">diff</span><span class="p">(</span><span class="n">ds_weighted_network_sdf</span><span class="p">)</span>

<span class="n">scaled_first_deriv</span> <span class="o">=</span> <span class="n">min_max_scaler</span><span class="p">.</span><span class="nf">fit_transform</span><span class="p">(</span><span class="n">first_deriv</span><span class="p">.</span><span class="nf">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>

<span class="n">plt</span><span class="p">.</span><span class="nf">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">scaled_ds_sdf</span><span class="p">.</span><span class="nf">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="sh">'</span><span class="s">black</span><span class="sh">'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">plot</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">scaled_first_deriv</span><span class="p">.</span><span class="nf">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="sh">'</span><span class="s">red</span><span class="sh">'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">xlim</span><span class="p">(</span><span class="mi">146</span><span class="p">,</span> <span class="mi">157</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(146.0, 157.0)
</code></pre></div></div>

<p><img width="100%" alt="image" src="../Non-Reverberating_Detection_files/Non-Reverberating_Detection_75_1.png"></p>

<p>Signal looks a lot smoother. Peaks of first derivative align with where burst starts and troughs align where burst generally end.</p>

<h2 id="detect-the-beginning-and-end-based-on-the-peaks-and-troughs-of-the-first-derivative">Detect the beginning and end based on the peaks and troughs of the first derivative</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Resample spike density function
</span><span class="n">ds_weighted_network_sdf</span> <span class="o">=</span> <span class="nf">resample</span><span class="p">(</span><span class="n">weighted_network_sdf</span><span class="p">,</span> <span class="nf">int</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">weighted_network_sdf</span><span class="p">)</span><span class="o">/</span><span class="n">RESAMPLE_FACTOR</span><span class="p">))</span>
<span class="c1"># Generate a new time array
</span><span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">duration</span><span class="p">,</span><span class="n">RESAMPLE_FACTOR</span><span class="o">/</span><span class="n">fs</span><span class="p">)</span>

<span class="c1"># Detect positive peaks (representing when the rate of increase is just about to go negative)
</span><span class="n">burst_start_ind</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="nf">find_peaks</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">diff</span><span class="p">(</span><span class="n">ds_weighted_network_sdf</span><span class="p">),</span> <span class="n">prominence</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
<span class="c1"># Detect positive peaks of negative SDF (representing when the rate of increase is just about to go positive)
</span><span class="n">burst_end_ind</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="nf">find_peaks</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="p">.</span><span class="nf">diff</span><span class="p">(</span><span class="n">ds_weighted_network_sdf</span><span class="p">),</span> <span class="n">prominence</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>

<span class="c1"># Assign detected peaks a time
</span><span class="n">burst_start</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">burst_start_ind</span><span class="p">]</span>
<span class="n">burst_end</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">burst_end_ind</span><span class="p">]</span>

<span class="c1"># Check if the array length is the same. In some cases, it may not be and you
# can either drop the extra value where the start and end do not alternate or you
# can put a bit of work and find the value.
</span><span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Length of burst_start is </span><span class="si">{</span><span class="nf">len</span><span class="p">(</span><span class="n">burst_start</span><span class="p">)</span><span class="si">}</span><span class="s"> and burst_end is </span><span class="si">{</span><span class="nf">len</span><span class="p">(</span><span class="n">burst_end</span><span class="p">)</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Length of burst_start is 100 and burst_end is 100
</code></pre></div></div>

<h3 id="visualize-the-above-work">Visualize the above work</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plt</span><span class="p">.</span><span class="nf">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="n">first_deriv</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">diff</span><span class="p">(</span><span class="n">ds_weighted_network_sdf</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">plot</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span><span class="n">first_deriv</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="sh">'</span><span class="s">black</span><span class="sh">'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">plot</span><span class="p">(</span><span class="n">burst_start</span><span class="p">,</span> <span class="n">first_deriv</span><span class="p">[</span><span class="n">burst_start_ind</span><span class="p">],</span> <span class="sh">'</span><span class="s">v</span><span class="sh">'</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="sh">'</span><span class="s">green</span><span class="sh">'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">plot</span><span class="p">(</span><span class="n">burst_end</span><span class="p">,</span> <span class="n">first_deriv</span><span class="p">[</span><span class="n">burst_end_ind</span><span class="p">],</span> <span class="sh">'</span><span class="s">^</span><span class="sh">'</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="sh">'</span><span class="s">red</span><span class="sh">'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">xlim</span><span class="p">(</span><span class="mi">146</span><span class="p">,</span> <span class="mi">157</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(146.0, 157.0)
</code></pre></div></div>

<p><img width="100%" alt="image" src="../Non-Reverberating_Detection_files/Non-Reverberating_Detection_80_1.png"></p>

<h3 id="wrap-the-above-into-a-function-as-we-dont-need-to-be-doing-this-type-of-eda-exploratory-data-analysis-every-time">Wrap the above into a function as we don’t need to be doing this type of EDA (exploratory data analysis) every time.</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">detect_burst_boundaries</span><span class="p">(</span><span class="n">weighted_network_sdf</span><span class="p">,</span> <span class="n">RESAMPLE_FACTOR</span><span class="o">=</span><span class="mi">150</span><span class="p">):</span>
  <span class="n">ds_weighted_network_sdf</span> <span class="o">=</span> <span class="nf">resample</span><span class="p">(</span><span class="n">weighted_network_sdf</span><span class="p">,</span> <span class="nf">int</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">weighted_network_sdf</span><span class="p">)</span><span class="o">/</span><span class="n">RESAMPLE_FACTOR</span><span class="p">))</span>
  <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">duration</span><span class="p">,</span><span class="n">RESAMPLE_FACTOR</span><span class="o">/</span><span class="n">fs</span><span class="p">)</span>
  <span class="n">burst_start_ind</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="nf">find_peaks</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">diff</span><span class="p">(</span><span class="n">ds_weighted_network_sdf</span><span class="p">),</span> <span class="n">prominence</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
  <span class="n">burst_end_ind</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="nf">find_peaks</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="p">.</span><span class="nf">diff</span><span class="p">(</span><span class="n">ds_weighted_network_sdf</span><span class="p">),</span> <span class="n">prominence</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
  <span class="n">burst_start</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">burst_start_ind</span><span class="p">]</span>
  <span class="n">burst_end</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">burst_end_ind</span><span class="p">]</span>
  <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Length of burst_start is </span><span class="si">{</span><span class="nf">len</span><span class="p">(</span><span class="n">burst_start</span><span class="p">)</span><span class="si">}</span><span class="s"> and burst_end is </span><span class="si">{</span><span class="nf">len</span><span class="p">(</span><span class="n">burst_end</span><span class="p">)</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">burst_start</span><span class="p">,</span> <span class="n">burst_end</span>

<span class="n">burst_start</span><span class="p">,</span> <span class="n">burst_end</span> <span class="o">=</span> <span class="nf">detect_burst_boundaries</span><span class="p">(</span><span class="n">weighted_network_sdf</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Length of burst_start is 100 and burst_end is 100
</code></pre></div></div>

<h2 id="assign-burst-boundaries-to-the-peaks-that-were-detected-if-possible">Assign burst boundaries to the peaks that were detected (if possible)</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">burst_borders</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">burst_peak</span> <span class="ow">in</span> <span class="n">burst_peak_times</span><span class="p">:</span>
  <span class="n">closest_start_to_peak</span> <span class="o">=</span> <span class="n">burst_start</span><span class="p">[</span><span class="n">burst_start</span> <span class="o">&lt;</span> <span class="n">burst_peak</span><span class="p">].</span><span class="nf">max</span><span class="p">()</span>
  <span class="n">closest_end_to_peak</span> <span class="o">=</span> <span class="n">burst_end</span><span class="p">[</span><span class="n">burst_end</span> <span class="o">&gt;</span> <span class="n">burst_peak</span><span class="p">].</span><span class="nf">min</span><span class="p">()</span>
  <span class="n">burst_borders</span><span class="p">.</span><span class="nf">append</span><span class="p">((</span><span class="n">closest_start_to_peak</span><span class="p">,</span> <span class="n">closest_end_to_peak</span><span class="p">))</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plt</span><span class="p">.</span><span class="nf">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="n">plt</span><span class="p">.</span><span class="n">rcParams</span><span class="p">.</span><span class="nf">update</span><span class="p">({</span><span class="sh">'</span><span class="s">font.size</span><span class="sh">'</span><span class="p">:</span> <span class="mi">12</span><span class="p">})</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">rc</span><span class="p">(</span><span class="sh">'</span><span class="s">axes</span><span class="sh">'</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">duration</span><span class="p">,</span><span class="mi">1</span><span class="o">/</span><span class="n">fs</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">eventplot</span><span class="p">(</span><span class="n">raster</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="sh">'</span><span class="s">black</span><span class="sh">'</span><span class="p">,</span> <span class="n">linelengths</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">linewidths</span><span class="o">=</span><span class="mf">0.75</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.35</span><span class="p">);</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">weighted_network_sdf</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="sh">'</span><span class="s">black</span><span class="sh">'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">xlim</span><span class="p">(</span><span class="mi">146</span><span class="p">,</span> <span class="mi">157</span><span class="p">)</span>
<span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">burst_borders</span><span class="p">:</span>
  <span class="n">plt</span><span class="p">.</span><span class="nf">axvline</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="sh">'</span><span class="s">green</span><span class="sh">'</span><span class="p">)</span>
  <span class="n">plt</span><span class="p">.</span><span class="nf">axvline</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="sh">'</span><span class="s">red</span><span class="sh">'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">ylabel</span><span class="p">(</span><span class="sh">"</span><span class="s">Firing Rate (Hz)</span><span class="sh">"</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">xlabel</span><span class="p">(</span><span class="sh">"</span><span class="s">Time (s)</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Text(0.5, 0, 'Time (s)')
</code></pre></div></div>

<p><img width="100%" alt="image" src="../Non-Reverberating_Detection_files/Non-Reverberating_Detection_85_1.png"></p>

<p>First derivative burst detection does a decent job. In this case, the network bursts may be terminating a bit too quickly. You can adjust this if you’d like but we’ll keep going. Importantly, there are no nested mini-bursts.</p>

<h1 id="reverberating-super-burst-reconstruction-loop">Reverberating Super Burst Reconstruction Loop</h1>
<p>Now that we have our Rmax (and if necessary, Amax) as well as our preliminary burst boundaries, we can now reconstructing the network events into reverberating super bursts if they meet the appropriate criteria. Do this only if “isReverb” is True.</p>

<p><strong>In this example, isReverb is false and therefore we will not proceed with reconstruction. Instead we will assign network event variables (ne_start, ne_end) as the burst boundaries we calculated just above.</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">burst_peaks</span> <span class="o">=</span> <span class="n">burst_peak_times</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="c1"># Because we ignored the first burst above
</span>
<span class="n">initiation_bursts</span> <span class="o">=</span> <span class="n">burst_peaks</span><span class="p">[</span><span class="n">labels</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span>
<span class="n">mini_bursts</span> <span class="o">=</span> <span class="n">burst_peaks</span><span class="p">[</span><span class="n">labels</span><span class="o">==</span><span class="mi">1</span><span class="p">]</span>

<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">duration</span><span class="p">,</span><span class="mi">1</span><span class="o">/</span><span class="mi">12500</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">weighted_network_sdf</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="sh">'</span><span class="s">black</span><span class="sh">'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">plot</span><span class="p">(</span><span class="n">initiation_bursts</span><span class="p">,</span> <span class="n">weighted_network_sdf</span><span class="p">[(</span><span class="n">initiation_bursts</span><span class="o">*</span><span class="n">fs</span><span class="p">).</span><span class="nf">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)],</span> <span class="sh">'</span><span class="s">v</span><span class="sh">'</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="sh">'</span><span class="s">green</span><span class="sh">'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">plot</span><span class="p">(</span><span class="n">mini_bursts</span><span class="p">,</span> <span class="n">weighted_network_sdf</span><span class="p">[(</span><span class="n">mini_bursts</span><span class="o">*</span><span class="n">fs</span><span class="p">).</span><span class="nf">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)],</span> <span class="sh">'</span><span class="s">v</span><span class="sh">'</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="sh">'</span><span class="s">red</span><span class="sh">'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">xlim</span><span class="p">(</span><span class="mi">146</span><span class="p">,</span> <span class="mi">157</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">ylabel</span><span class="p">(</span><span class="sh">"</span><span class="s">Firing Rate (Hz)</span><span class="sh">"</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">xlabel</span><span class="p">(</span><span class="sh">"</span><span class="s">Time (s)</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Text(0.5, 0, 'Time (s)')
</code></pre></div></div>

<p><img width="100%" alt="image" src="../Non-Reverberating_Detection_files/Non-Reverberating_Detection_88_1.png"></p>

<h2 id="merge-the-burst-boundaries-of-all-possible-bursts-into-larger-complex-network-events-if-they-meet-the-criteria">Merge the burst boundaries of all possible bursts into larger, complex network events if they meet the criteria</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">merge_bursts_into_RSB</span><span class="p">(</span><span class="n">rmax</span><span class="p">,</span> <span class="n">burst_borders</span><span class="p">,</span> <span class="n">prime_burst_peak_times</span><span class="p">,</span> <span class="n">burst_peak_times</span><span class="p">):</span>
  <span class="sh">'''</span><span class="s">
  Rmax: either hist_rmax or overlap_rmax
  Burst borders: start and end tuple for each burst peak that we just recently calculated
  Prime_burst_peak_times: a variable we calculated close to the top where the only peaks
  would meet the criteria of a high prominence were detected
  Burst_peak_times: all possible burst peaks
  </span><span class="sh">'''</span>
  <span class="n">ne_start</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="n">ne_end</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="n">nReverbs</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="n">in_super_burst</span> <span class="o">=</span> <span class="bp">False</span>
  <span class="n">initial_burst</span> <span class="o">=</span> <span class="bp">False</span>

  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">burst_borders</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
    <span class="nf">if </span><span class="p">(</span><span class="n">burst_peak_times</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">in</span> <span class="n">prime_burst_peak_times</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">initial_burst</span> <span class="o">==</span> <span class="bp">True</span><span class="p">):</span>
      <span class="n">initial_burst</span> <span class="o">=</span> <span class="bp">False</span>
      <span class="n">ne_end</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">burst_borders</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
      <span class="n">nReverbs</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
      <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="nf">if </span><span class="p">(</span><span class="n">burst_peak_times</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">in</span> <span class="n">prime_burst_peak_times</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">initial_burst</span> <span class="o">==</span> <span class="bp">False</span><span class="p">):</span>
      <span class="n">initial_burst</span> <span class="o">=</span> <span class="bp">True</span>
      <span class="n">ne_start</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">burst_borders</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
    <span class="nf">if </span><span class="p">((</span><span class="n">burst_borders</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">burst_borders</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="n">rmax</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">initial_burst</span> <span class="o">==</span> <span class="bp">True</span><span class="p">):</span>
      <span class="k">if</span> <span class="n">in_super_burst</span><span class="p">:</span>
        <span class="n">r</span> <span class="o">+=</span> <span class="mi">1</span>
      <span class="n">in_super_burst</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="nf">elif </span><span class="p">((</span><span class="n">burst_borders</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">burst_borders</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">rmax</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">initial_burst</span> <span class="o">==</span> <span class="bp">True</span><span class="p">):</span>
      <span class="k">if</span> <span class="n">in_super_burst</span><span class="p">:</span>
        <span class="n">r</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">in_super_burst</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">initial_burst</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">ne_end</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">burst_borders</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">nReverbs</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="nf">if </span><span class="p">(</span><span class="n">burst_peak_times</span><span class="p">[</span><span class="nf">len</span><span class="p">(</span><span class="n">burst_borders</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">prime_burst_peak_times</span><span class="p">):</span>
   <span class="n">ne_start</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">burst_borders</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
   <span class="n">ne_end</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">burst_borders</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
  <span class="k">else</span><span class="p">:</span>
   <span class="n">ne_end</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">burst_borders</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
   <span class="n">nReverbs</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">ne_start</span><span class="p">,</span> <span class="n">ne_end</span><span class="p">,</span> <span class="n">nReverbs</span>

<span class="k">if</span> <span class="n">isReverb</span><span class="o">==</span><span class="bp">True</span><span class="p">:</span>
  <span class="n">ne_start</span><span class="p">,</span> <span class="n">ne_end</span><span class="p">,</span> <span class="n">nReverbs</span> <span class="o">=</span> <span class="nf">merge_bursts_into_RSB</span><span class="p">(</span><span class="n">overlap_rmax</span><span class="p">,</span> <span class="n">burst_borders</span><span class="p">,</span> <span class="n">prime_burst_peak_times</span><span class="p">,</span> <span class="n">burst_peak_times</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
  <span class="n">ne_start</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">burst_borders</span><span class="p">]</span>
  <span class="n">ne_end</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">burst_borders</span><span class="p">]</span>
  <span class="n">nReverbs</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">burst_borders</span><span class="p">))</span>
</code></pre></div></div>

<h3 id="visualize-if-the-merging-worked-appropriately">Visualize if the merging worked appropriately</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plt</span><span class="p">.</span><span class="nf">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="n">plt</span><span class="p">.</span><span class="n">rcParams</span><span class="p">.</span><span class="nf">update</span><span class="p">({</span><span class="sh">'</span><span class="s">font.size</span><span class="sh">'</span><span class="p">:</span> <span class="mi">12</span><span class="p">})</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">rc</span><span class="p">(</span><span class="sh">'</span><span class="s">axes</span><span class="sh">'</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">duration</span><span class="p">,</span><span class="mi">1</span><span class="o">/</span><span class="n">fs</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">eventplot</span><span class="p">(</span><span class="n">raster</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="sh">'</span><span class="s">black</span><span class="sh">'</span><span class="p">,</span> <span class="n">linelengths</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">linewidths</span><span class="o">=</span><span class="mf">0.75</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.35</span><span class="p">);</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">weighted_network_sdf</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="sh">'</span><span class="s">black</span><span class="sh">'</span><span class="p">)</span>
<span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">ne_start</span><span class="p">:</span>
  <span class="n">plt</span><span class="p">.</span><span class="nf">axvline</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="sh">'</span><span class="s">green</span><span class="sh">'</span><span class="p">)</span>
<span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">ne_end</span><span class="p">:</span>
  <span class="n">plt</span><span class="p">.</span><span class="nf">axvline</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="sh">'</span><span class="s">red</span><span class="sh">'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">ylabel</span><span class="p">(</span><span class="sh">"</span><span class="s">Firing Rate (Hz)</span><span class="sh">"</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">xlabel</span><span class="p">(</span><span class="sh">"</span><span class="s">Time (s)</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Text(0.5, 0, 'Time (s)')
</code></pre></div></div>

<p><img width="100%" alt="image" src="../Non-Reverberating_Detection_files/Non-Reverberating_Detection_92_1.png"></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plt</span><span class="p">.</span><span class="nf">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="n">plt</span><span class="p">.</span><span class="n">rcParams</span><span class="p">.</span><span class="nf">update</span><span class="p">({</span><span class="sh">'</span><span class="s">font.size</span><span class="sh">'</span><span class="p">:</span> <span class="mi">12</span><span class="p">})</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">rc</span><span class="p">(</span><span class="sh">'</span><span class="s">axes</span><span class="sh">'</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">duration</span><span class="p">,</span><span class="mi">1</span><span class="o">/</span><span class="n">fs</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">eventplot</span><span class="p">(</span><span class="n">raster</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="sh">'</span><span class="s">black</span><span class="sh">'</span><span class="p">,</span> <span class="n">linelengths</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">linewidths</span><span class="o">=</span><span class="mf">0.75</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.35</span><span class="p">);</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">weighted_network_sdf</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="sh">'</span><span class="s">black</span><span class="sh">'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">xlim</span><span class="p">(</span><span class="mi">136</span><span class="p">,</span> <span class="mi">167</span><span class="p">)</span>
<span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">ne_start</span><span class="p">:</span>
  <span class="n">plt</span><span class="p">.</span><span class="nf">axvline</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="sh">'</span><span class="s">green</span><span class="sh">'</span><span class="p">)</span>
<span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">ne_end</span><span class="p">:</span>
  <span class="n">plt</span><span class="p">.</span><span class="nf">axvline</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="sh">'</span><span class="s">red</span><span class="sh">'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">ylabel</span><span class="p">(</span><span class="sh">"</span><span class="s">Firing Rate (Hz)</span><span class="sh">"</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">xlabel</span><span class="p">(</span><span class="sh">"</span><span class="s">Time (s)</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Text(0.5, 0, 'Time (s)')
</code></pre></div></div>

<p><img width="100%" alt="image" src="../Non-Reverberating_Detection_files/Non-Reverberating_Detection_93_1.png"></p>

<h2 id="and-there-you-have-it--detection-of-network-events-using-the-same-code-as-the-reverberating-super-burst-detection-you-can-similarily-proceed-with-calculating-features-however-reverberating-super-burst-specific-features-will-not-be-informative">and there you have it! 🎉🎉🎉 Detection of network events using the same code as the reverberating super burst detection. You can similarily proceed with calculating features however reverberating super burst specific features will not be informative.</h2>

<p>.</p>

<p>.</p>

<h1 id="feature-calculation">Feature Calculation</h1>

<h3 id="number-of-mini-bursts-per-reverberating-super-burst">Number of mini-bursts per reverberating super burst</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sns</span><span class="p">.</span><span class="nf">histplot</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">nReverbs</span><span class="p">,</span> <span class="n">binrange</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p">),</span> <span class="n">bins</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">xlabel</span><span class="p">(</span><span class="sh">"</span><span class="s">Number of mini-bursts per RSB</span><span class="sh">"</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">axvline</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">mean</span><span class="p">(</span><span class="n">nReverbs</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="sh">'</span><span class="s">black</span><span class="sh">'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">axvline</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">median</span><span class="p">(</span><span class="n">nReverbs</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="sh">'</span><span class="s">red</span><span class="sh">'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">legend</span><span class="p">([</span><span class="sa">f</span><span class="sh">"</span><span class="s">Mean (</span><span class="si">{</span><span class="n">np</span><span class="p">.</span><span class="nf">mean</span><span class="p">(</span><span class="n">nReverbs</span><span class="p">)</span><span class="si">}</span><span class="s">)</span><span class="sh">"</span><span class="p">,</span><span class="sa">f</span><span class="sh">"</span><span class="s">Median (</span><span class="si">{</span><span class="n">np</span><span class="p">.</span><span class="nf">median</span><span class="p">(</span><span class="n">nReverbs</span><span class="p">)</span><span class="si">}</span><span class="s">)</span><span class="sh">"</span><span class="p">])</span>
<span class="n">sns</span><span class="p">.</span><span class="nf">despine</span><span class="p">()</span>
</code></pre></div></div>

<p><img width="75%" alt="image" src="../Non-Reverberating_Detection_files/Non-Reverberating_Detection_99_0.png"></p>

<p>This network had a median number of 4 mini-bursts per reverberating super bursts. Quite the active one! In this case, not a single non-reverberating network event was seen.</p>

<h3 id="network-event-duration">Network Event Duration</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ne_duration</span> <span class="o">=</span> <span class="p">[</span><span class="n">ne_end</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">ne_start</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">ne_start</span><span class="p">))]</span>

<span class="n">sns</span><span class="p">.</span><span class="nf">histplot</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">ne_duration</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">xlabel</span><span class="p">(</span><span class="sh">"</span><span class="s">Network Event Duration (s)</span><span class="sh">"</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">axvline</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">mean</span><span class="p">(</span><span class="n">ne_duration</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="sh">'</span><span class="s">black</span><span class="sh">'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">axvline</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">median</span><span class="p">(</span><span class="n">ne_duration</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="sh">'</span><span class="s">red</span><span class="sh">'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">legend</span><span class="p">([</span><span class="sa">f</span><span class="sh">"</span><span class="s">Mean (</span><span class="si">{</span><span class="n">np</span><span class="p">.</span><span class="nf">mean</span><span class="p">(</span><span class="n">ne_duration</span><span class="p">)</span><span class="si">}</span><span class="s">)</span><span class="sh">"</span><span class="p">,</span><span class="sa">f</span><span class="sh">"</span><span class="s">Median (</span><span class="si">{</span><span class="n">np</span><span class="p">.</span><span class="nf">median</span><span class="p">(</span><span class="n">ne_duration</span><span class="p">)</span><span class="si">}</span><span class="s">)</span><span class="sh">"</span><span class="p">])</span>
<span class="n">sns</span><span class="p">.</span><span class="nf">despine</span><span class="p">()</span>
</code></pre></div></div>

<p><img width="75%" alt="image" src="../Non-Reverberating_Detection_files/Non-Reverberating_Detection_102_0.png"></p>

<p>On average, this network had a network event duration of approximately 2 seconds. Based on this duration, and the previously calculated number of mini-bursts, what is the mini-burst frequency per reverberating super burst?</p>

<h3 id="mini-burst-frequency">Mini-burst Frequency</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mb_frequency</span> <span class="o">=</span> <span class="p">[</span><span class="n">nReverbs</span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="o">/</span><span class="n">ne_duration</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">ne_duration</span><span class="p">))]</span>

<span class="n">sns</span><span class="p">.</span><span class="nf">histplot</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">mb_frequency</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">xlabel</span><span class="p">(</span><span class="sh">"</span><span class="s">Mini-burst frequency (Hz)</span><span class="sh">"</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">axvline</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">mean</span><span class="p">(</span><span class="n">mb_frequency</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="sh">'</span><span class="s">black</span><span class="sh">'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">axvline</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">median</span><span class="p">(</span><span class="n">mb_frequency</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="sh">'</span><span class="s">red</span><span class="sh">'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">legend</span><span class="p">([</span><span class="sa">f</span><span class="sh">"</span><span class="s">Mean (</span><span class="si">{</span><span class="n">np</span><span class="p">.</span><span class="nf">mean</span><span class="p">(</span><span class="n">mb_frequency</span><span class="p">)</span><span class="si">}</span><span class="s">)</span><span class="sh">"</span><span class="p">,</span><span class="sa">f</span><span class="sh">"</span><span class="s">Median (</span><span class="si">{</span><span class="n">np</span><span class="p">.</span><span class="nf">median</span><span class="p">(</span><span class="n">mb_frequency</span><span class="p">)</span><span class="si">}</span><span class="s">)</span><span class="sh">"</span><span class="p">])</span>
<span class="n">sns</span><span class="p">.</span><span class="nf">despine</span><span class="p">()</span>
</code></pre></div></div>

<p><img width="75%" alt="image" src="../Non-Reverberating_Detection_files/Non-Reverberating_Detection_105_0.png"></p>

<p>The vast majority of reverberating super bursts had a mini-burst frequency between 1.5-2.1 Hz. Fairly consistent frequency.</p>

<h3 id="inter-network-event-interval">Inter-Network-Event-Interval</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">i_ne_i</span> <span class="o">=</span> <span class="p">[</span><span class="n">ne_start</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">ne_end</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nf">len</span><span class="p">(</span><span class="n">ne_start</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>

<span class="n">sns</span><span class="p">.</span><span class="nf">histplot</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">i_ne_i</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">xlabel</span><span class="p">(</span><span class="sh">"</span><span class="s">Inter-Network-Event-Interval (s)</span><span class="sh">"</span><span class="p">)</span>
<span class="n">sns</span><span class="p">.</span><span class="nf">despine</span><span class="p">()</span>
</code></pre></div></div>

<p><img width="75%" alt="image" src="../Non-Reverberating_Detection_files/Non-Reverberating_Detection_108_0.png"></p>


  </article>
  <h2>References</h2>
  <div class="publications">
    <h2 class="bibliography">2023</h2>
<ol class="bibliography"><li>
<!-- _layouts/bib.html -->
      <div class="row">
<!-- Entry bib key -->
        <div id="Pradeepan2023.09.12.557388" class="col-sm-10">
        <!-- Title -->
        <div class="title">Hyperexcitability in human MECP2 null neuronal networks manifests as calcium-dependent reverberating super bursts</div>
        <!-- Author -->
        <div class="author">
        

        Kartik S Pradeepan, Fraser P McCready, Wei Wei, Milad Khaki, and
          <span class="more-authors" title="click to view 4 more authors" onclick="
                var element = $(this);
                element.attr('title', '');
                var more_authors_text = element.text() == '4 more authors' ? 'Wenbo Zhang, Michael W Salter, James Ellis, Julio Martinez-Trujillo' : '4 more authors';
                var cursorPosition = 0;
                var textAdder = setInterval(function(){
                  element.text(more_authors_text.substring(0, cursorPosition + 1));
                  if (++cursorPosition == more_authors_text.length){
                    clearInterval(textAdder);
                  }
              }, '5');
              ">4 more authors</span>
</div>

        <!-- Journal/Book title and date -->
        
        
        <div class="periodical">
          <em>bioRxiv</em>, 2023
        </div>
        <div class="periodical">
          
        </div>

          <!-- Links/Buttons -->
          <div class="links">
            <a class="abstract btn btn-sm z-depth-0" role="button">Abs</a>
          </div>
          
          
          
          

          <!-- Hidden abstract block -->
          <div class="abstract hidden">
            <p>Rett syndrome (RTT) patients show abnormal developmental trajectories including loss of language and repetitive hand movements but also have signs of cortical hyperexcitability such as seizures. RTT is predominantly caused by mutations in MECP2 and can be modelled in vitro using human stem cell-derived neurons. MECP2 null excitatory neurons are smaller in soma size and have reduced synaptic connectivity but are also hyperexcitable, due to higher input resistance, which increases the chance to evoke action potentials with a given depolarized current. Few studies examine how single neuron activity integrates into neuronal networks during human development. Paradoxically, networks of MECP2 null neurons show a decrease in the frequency of bursting patterns consistent with synaptic hypoconnectivity, but no hyperexcitable network events have been reported. Here, we show that MECP2 null neurons have an increase in the frequency of a network event described as reverberating super bursts (RSBs) relative to isogenic controls. RSBs can be mistakenly called as a single long duration burst by standard burst detection algorithms. However, close examination revealed an initial large amplitude network burst followed by high frequency repetitive low amplitude mini-bursts. Using a custom burst detection algorithm, we unfolded the multi-burst structure of RSBs revealing that MECP2 null networks increased the total number of bursts relative to isogenic controls. Application of the Ca2+ chelator EGTA-AM selectively eliminated RSBs and rescued the network burst phenotype relative to the isogenic controls. Our results indicate that during early development, MECP2 null neurons are hyperexcitable and produce hyperexcitable networks. This may predispose them to the emergence of hyper-synchronic states that potentially translate into seizures. Network hyperexcitability is dependent on asynchronous neurotransmitter release driven by pre-synaptic Ca2+ and can be rescued by EGTA-AM to restore typical network dynamics.Reverberating super-bursts (RSBs) follow a stereotypic form of a large initial network burst followed by several smaller amplitude high-frequency mini-bursts.RSBs occur more often in MECP2 null excitatory networks.MECP2 null excitatory networks with increased RSBs show a hyperexcitable network burst phenotype relative to isogenic controls.The calcium chelator, EGTA-AM, decreases RSBs and rescues the dynamics of MECP2 null hyperexcitable networks.</p>
          </div>
        </div>
      </div>
</li></ol>
  </div>
</div>

      
    </div>

    <!-- Footer -->    
    <footer class="fixed-bottom">
      <div class="container mt-0">
        © Copyright 2024 Kartik  Pradeepan. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme.
Last updated: January 15, 2024.
      </div>
    </footer>

    <!-- JavaScripts -->
    <!-- jQuery -->
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>

    <!-- Bootsrap & MDB scripts -->
  <script src="/assets/js/bootstrap.bundle.min.js"></script>
  <!-- <script src="/assets/js/mdb.min.js"></script> -->
  <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script>

    <!-- Masonry & imagesLoaded -->
  <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script>
  <script defer src="/assets/js/masonry.js" type="text/javascript"></script>
    
  <!-- Medium Zoom JS -->
  <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script>
  <script defer src="/assets/js/zoom.js?7b30caa5023af4af8408a472dc4e1ebb"></script>

  <!-- Bootstrap Table -->
  <script defer src="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.js"></script>

  <!-- Load Common JS -->
  <script src="/assets/js/no_defer.js?d633890033921b33e0ceb13d22340a9c"></script>
  <script defer src="/assets/js/common.js?acdb9690d7641b2f8d40529018c71a01"></script>
  <script defer src="/assets/js/copy_code.js?07b8786bab9b4abe90d10e61f7d12ff7" type="text/javascript"></script>

    
  <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script>
  <script async src="https://badge.dimensions.ai/badge.js"></script>

    <!-- MathJax -->
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        tags: 'ams'
      }
    };
  </script>
  <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script>
  <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>

    <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-M1JHV55BQ5"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){ window.dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'G-M1JHV55BQ5');
  </script>
    

<!-- Scrolling Progress Bar -->
<script type="text/javascript">
  /*
   * This JavaScript code has been adapted from the article 
   * https://css-tricks.com/reading-position-indicator/ authored by Pankaj Parashar, 
   * published on the website https://css-tricks.com on the 7th of May, 2014.
   * Couple of changes were made to the original code to make it compatible 
   * with the `al-foio` theme.
   */
  const progressBar = $("#progress");
  /*
   * We set up the bar after all elements are done loading.
   * In some cases, if the images in the page are larger than the intended
   * size they'll have on the page, they'll be resized via CSS to accomodate
   * the desired size. This mistake, however, breaks the computations as the
   * scroll size is computed as soon as the elements finish loading.
   * To account for this, a minimal delay was introduced before computing the
   * values.
   */
  window.onload = function () {
    setTimeout(progressBarSetup, 50);
  };
  /*
   * We set up the bar according to the browser.
   * If the browser supports the progress element we use that.
   * Otherwise, we resize the bar thru CSS styling
   */
  function progressBarSetup() {
    if ("max" in document.createElement("progress")) {
      initializeProgressElement();
      $(document).on("scroll", function() {
        progressBar.attr({ value: getCurrentScrollPosition() });
      });
      $(window).on("resize", initializeProgressElement);
    } else {
      resizeProgressBar();
      $(document).on("scroll", resizeProgressBar);
      $(window).on("resize", resizeProgressBar);
    }
  }
  /*
   * The vertical scroll position is the same as the number of pixels that
   * are hidden from view above the scrollable area. Thus, a value > 0 is
   * how much the user has scrolled from the top
   */
  function getCurrentScrollPosition() {
    return $(window).scrollTop();
  }

  function initializeProgressElement() {
    let navbarHeight = $("#navbar").outerHeight(true);
    $("body").css({ "padding-top": navbarHeight });
    $("progress-container").css({ "padding-top": navbarHeight });
    progressBar.css({ top: navbarHeight });
    progressBar.attr({
      max: getDistanceToScroll(),
      value: getCurrentScrollPosition(),
    });
  }
  /*
   * The offset between the html document height and the browser viewport
   * height will be greater than zero if vertical scroll is possible.
   * This is the distance the user can scroll
   */
  function getDistanceToScroll() {
    return $(document).height() - $(window).height();
  }

  function resizeProgressBar() {
    progressBar.css({ width: getWidthPercentage() + "%" });
  }
  // The scroll ratio equals the percentage to resize the bar
  function getWidthPercentage() {
    return (getCurrentScrollPosition() / getDistanceToScroll()) * 100;
  }
</script>

    
  </body>
</html>
